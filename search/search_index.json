{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to CytoBulk documentation!","text":""},{"location":"#cytobulk-library","title":"CytoBulk Library","text":"<p>A tool that integrates bulk RNA, single-cell RNA (scRNA), spatial transcriptome (ST), and H&amp;E images to deconvolute the TIME from bulk or spot data using graph frequency domain modeling; and reconstructs the TIME to single-cell resolution using optimal transport methods.</p>"},{"location":"APIs/","title":"API references","text":""},{"location":"APIs/#tools","title":"tools","text":"<ul> <li>deconv</li> <li>mapping</li> <li>segmentation</li> </ul>"},{"location":"APIs/#plots","title":"plots","text":"<ul> <li>plot</li> </ul>"},{"location":"Examples/","title":"Examples","text":""},{"location":"Examples/#st-data-deconvolution-and-spot-annotation","title":"ST data deconvolution and spot annotation","text":""},{"location":"Examples/#bulk-deconvolution-and-mapping-with-scrna-seq","title":"Bulk deconvolution and mapping with scRNA-seq","text":""},{"location":"Examples/#st-deconvolution-and-mapping-with-scrna-seq","title":"ST deconvolution and mapping with scRNA-seq","text":""},{"location":"Examples/#he-cell-prediction-and-integration-with-scrna-seq","title":"H&amp;E cell prediction and integration with scRNA-seq","text":""},{"location":"Install/","title":"Installation Guide","text":"<p>Follow the steps below to install and set up CytoBulk.</p>"},{"location":"Install/#setting-up-the-environment-for-python-and-r","title":"Setting Up the Environment for Python and R","text":"<p>The CytoBulk package is developed based on the pytorch framework and can be implemented on both GPU and CPU. We recommend running the package on GPU. Please ensure that pytorch and CUDNN are installed correctly.</p>"},{"location":"Install/#option-1-set-python-and-r-together","title":"Option 1: Set Python and R Together","text":"<p><pre><code>conda config --append channels conda-forge\nconda create --name cytobulk python=3.10 r-base=4.4\nconda activate cytobulk\npip install cytobulk\n</code></pre> This approach is suitable for users who want all dependencies managed within the same Conda environment. However, it might not work reliably on Windows due to potential issues with R configuration in Conda.</p>"},{"location":"Install/#option-2-set-only-python-and-specify-r-path-separately","title":"Option 2: Set Only Python and Specify R Path Separately","text":"<p><pre><code>conda create --name cytobulk python=3.10\nconda activate cytobulk\npip install cytobulk\n</code></pre> Then, before running the main program, you need to specify the path to your locally installed R. This can be done using Python by setting the R_HOME environment variable. Add the following lines at the beginning of your Python script: <pre><code>import os\n# Set the R installation path (adjust the path based on your R installation)\nos.environ['R_HOME'] = r_path\n</code></pre></p>"},{"location":"Install/#install-required-r-packages","title":"Install required R packages","text":"<p>To run CytoBulk, make sure all the following prerequisites are installed.</p> <p>R 4.4.0 or higher and the following packages </p> <ul> <li>Giotto (1.1.2) https://giottosuite.readthedocs.io/en/master/gettingstarted.html</li> <li>scran (1.32.0) https://bioconductor.org/packages/release/bioc/html/scran.html</li> <li>sva (3.52.0) https://www.bioconductor.org/packages/release/bioc/html/sva.html</li> </ul>"},{"location":"References/","title":"References","text":"<ul> <li>Stahl, Patrik L., et al. \"Visualization and analysis of gene expression in tissue sections by spatial transcriptomics.\" Science 353.6294 (2016): 78-82.</li> <li>Tepe, Burak, et al. \"Single-cell RNA-seq of mouse olfactory bulb reveals cellular heterogeneity and activity-dependent molecular census of adult-born neurons.\" Cell reports 25.10 (2018): 2689-2703.</li> <li>Wu, Sunny Z., et al. \"A single-cell and spatially resolved atlas of human breast cancers.\" Nature genetics 53.9 (2021): 1334-1347.</li> <li>Janesick, Amanda, et al. \"High resolution mapping of the tumor microenvironment using integrated single-cell, spatial and in situ analysis.\" Nature Communications 14.1 (2023): 8353.</li> <li>Chan, Joseph M., et al. \"Signatures of plasticity, metastasis, and immunosuppression in an atlas of human small cell lung cancer.\" Cancer cell 39.11 (2021): 1479-1496.</li> </ul>"},{"location":"plots/","title":"plots","text":"<ul> <li>_eval_plot</li> <li>_plot</li> </ul>"},{"location":"plots/_eval_plot/","title":"eval plot","text":""},{"location":"plots/_eval_plot/#cytobulk.plots._plot.Const","title":"<code>Const</code>","text":"<p>Some COLOR SET used in the class.</p> Source code in <code>cytobulk\\plots\\_plot.py</code> <pre><code>class Const:\n    \"\"\"\n    Some COLOR SET used in the class.\n\n    \"\"\"\n    DIFF_COLOR_2 = ['#011F5B','#F19CBB']\n    #DIFF_COLOR_N = ['#005f73','#94d2bd','#e9d8a6','#fac748','#e76f51','#9b2226']\n    DIFF_COLOR_N = ['#191970','#ADD8E6','#005f73','#94d2bd','#e9d8a6','#fac748','#e76f51','#9b2226']\n</code></pre>"},{"location":"plots/_eval_plot/#cytobulk.plots._plot.plot_celltype_fraction_heatmap","title":"<code>plot_celltype_fraction_heatmap(adata, label, r=0.1, out_dir='/plot', project_name='project', color_map='crest', rotation_angle=None, figsize=(2.7, 2))</code>","text":"<p>Plot a heatmap of cell type fractions at spatial coordinates.</p> <p>This function visualizes the fraction of a specified cell type as a heatmap on a 2D scatter plot, using spatial transcriptomics data. The color intensity of each point corresponds to the cell type fraction at that spatial location. The resulting figure is saved as an SVG file.</p> <p>Parameters:</p> Name Type Description Default <code>adata</code> <code>AnnData</code> <p>An :class:<code>~anndata.AnnData</code> object containing spatial transcriptomics data. The spatial coordinates should be stored in <code>adata.obsm['spatial']</code>, and the deconvolution results (cell type fractions) should be stored in <code>adata.uns['deconv']</code>.</p> required <code>label</code> <code>string</code> <p>The name of the cell type to plot. This should correspond to one of the columns in <code>adata.uns['deconv']</code>, which represents the fractions of different cell types.</p> required <code>r</code> <code>float, optional (default: 0.1)</code> <p>Radius of the points representing the cell type fractions at each spatial coordinate.</p> <code>0.1</code> <code>out_dir</code> <code>string, optional (default: '/plot')</code> <p>The directory where the output figure (SVG format) will be saved.</p> <code>'/plot'</code> <code>project_name</code> <code>string, optional (default: 'project')</code> <p>The prefix to use for the saved SVG file.</p> <code>'project'</code> <code>color_map</code> <code>string, optional (default: 'crest')</code> <p>The name of the colormap to use for the heatmap. This can be any colormap recognized by <code>seaborn</code> or <code>matplotlib</code>.</p> <code>'crest'</code> <code>rotation_angle</code> <code>float, optional (default: None)</code> <p>An optional angle (in degrees) to rotate the spatial coordinates. If provided, the rotation is applied to the coordinates before plotting.</p> <code>None</code> <code>figsize</code> <code>tuple, optional (default: (2.7, 2))</code> <p>The size of the output figure, specified as a tuple of (width, height) in inches.</p> <code>(2.7, 2)</code> <p>Returns:</p> Type Description <code>None</code> <p>The function does not return any values but saves the generated heatmap plot as an SVG file in the specified <code>out_dir</code>.</p> Source code in <code>cytobulk\\plots\\_plot.py</code> <pre><code>def plot_celltype_fraction_heatmap(adata,\n                                   label,\n                                    r=0.1,\n                                    out_dir='/plot',\n                                    project_name='project',\n                                    color_map='crest',\n                                    rotation_angle=None,\n                                    figsize=(2.7, 2)):\n    \"\"\"\n    Plot a heatmap of cell type fractions at spatial coordinates.\n\n    This function visualizes the fraction of a specified cell type as a heatmap on a 2D scatter plot, using spatial transcriptomics data. The color intensity of each point corresponds to the cell type fraction at that spatial location. The resulting figure is saved as an SVG file.\n\n    Parameters\n    ----------\n    adata : anndata.AnnData\n        An :class:`~anndata.AnnData` object containing spatial transcriptomics data.\n        The spatial coordinates should be stored in `adata.obsm['spatial']`, and the deconvolution results (cell type fractions) should be stored in `adata.uns['deconv']`.\n\n    label : string\n        The name of the cell type to plot. This should correspond to one of the columns in `adata.uns['deconv']`, which represents the fractions of different cell types.\n\n    r : float, optional (default: 0.1)\n        Radius of the points representing the cell type fractions at each spatial coordinate.\n\n    out_dir : string, optional (default: '/plot')\n        The directory where the output figure (SVG format) will be saved.\n\n    project_name : string, optional (default: 'project')\n        The prefix to use for the saved SVG file.\n\n    color_map : string, optional (default: 'crest')\n        The name of the colormap to use for the heatmap. This can be any colormap recognized by `seaborn` or `matplotlib`.\n\n    rotation_angle : float, optional (default: None)\n        An optional angle (in degrees) to rotate the spatial coordinates. If provided, the rotation is applied to the coordinates before plotting.\n\n    figsize : tuple, optional (default: (2.7, 2))\n        The size of the output figure, specified as a tuple of (width, height) in inches.\n\n    Returns\n    -------\n    None\n        The function does not return any values but saves the generated heatmap plot as an SVG file in the specified `out_dir`.\n    \"\"\"\n    from sklearn.preprocessing import minmax_scale\n    fig, ax = plt.subplots(figsize=figsize)\n    plt.xticks([])\n    plt.yticks([])\n    plt.axis('off')\n    loc_xy=adata.obsm['spatial']\n    loc_xy=pd.DataFrame(loc_xy,columns=['x','y'],index=adata.obs_names)\n    if rotation_angle:\n        new_loc = loc_xy.apply(lambda x : utils.rotate_matrix(x['x'],x['y'],rotation_angle), axis=1)\n        loc_xy = pd.DataFrame(list(new_loc),columns=loc_xy.columns,index=loc_xy.index)\n    cell_type_fraction = adata.uns['deconv']\n    cell_type_fraction['x']=loc_xy['x']\n    cell_type_fraction['y']=loc_xy['y']\n    cell_type_fraction[label] = minmax_scale(cell_type_fraction[label].values)\n    sns.scatterplot(data=cell_type_fraction, x=\"x\", y=\"y\",palette=color_map,hue=label,s=20,legend=False,edgecolor=\"None\",markers=\"pentagon\")\n    norm = plt.Normalize(cell_type_fraction[label].min(), cell_type_fraction[label].max())\n    cmap = sns.color_palette(color_map, as_cmap=True)\n    sm = plt.cm.ScalarMappable(cmap=cmap, norm=norm)\n    sm.set_array([])\n    cax = fig.add_axes([ax.get_position().x1+0.05, ax.get_position().y0, 0.03, ax.get_position().height])\n    ax.set_title(f'{label}',fontsize=10,x=ax.get_position().x1/2,y=ax.get_position().y1+0.1)\n    ax.figure.colorbar(sm, cax=cax)\n    fig.show()\n    fig.savefig(f\"{out_dir}/{project_name}_{label}.svg\", format=\"svg\", dpi=1200,bbox_inches = 'tight',transparent = True)\n</code></pre>"},{"location":"plots/_eval_plot/#cytobulk.plots._plot.plot_celltype_fraction_pie","title":"<code>plot_celltype_fraction_pie(adata, scale_facter_x=1, scale_factor_y=1, r=0.1, out_dir='/plot', project_name='project', color_list=None, color_map='Spectral', rotation_angle=None, figsize=(2, 2))</code>","text":"<p>Plot cell type fraction as pie charts at spatial coordinates.</p> <p>This function generates pie charts representing the cell type fraction at each spatial location (from the 'spatial' data in <code>adata</code>) and plots them on a 2D scatter plot. Each pie chart is positioned based on the spatial coordinates and reflects the relative abundance of each cell type at that spot. The resulting figure is saved as an SVG file.</p> <p>Parameters:</p> Name Type Description Default <code>adata</code> <code>AnnData</code> <p>An :class:<code>~anndata.AnnData</code> object containing spatial transcriptomics data. The spatial coordinates should be stored in <code>adata.obsm['spatial']</code>, and the deconvolution results (cell type fractions) should be stored in <code>adata.uns['deconv']</code>.</p> required <code>scale_facter_x</code> <code>float, optional (default: 1)</code> <p>A scaling factor to apply to the X-axis coordinates of the spatial data.</p> <code>1</code> <code>scale_factor_y</code> <code>float, optional (default: 1)</code> <p>A scaling factor to apply to the Y-axis coordinates of the spatial data.</p> <code>1</code> <code>r</code> <code>float, optional (default: 0.1)</code> <p>Radius of the pie charts representing cell type fractions at each spatial coordinate.</p> <code>0.1</code> <code>out_dir</code> <code>string, optional (default: '/plot')</code> <p>The directory where the output figure (SVG format) will be saved.</p> <code>'/plot'</code> <code>project_name</code> <code>string, optional (default: 'project')</code> <p>The prefix to use for the saved SVG file.</p> <code>'project'</code> <code>color_list</code> <code>list, optional (default: None)</code> <p>A list of colors to use for the cell types. If <code>None</code>, a colormap (specified by <code>color_map</code>) will be used to generate colors for each cell type.</p> <code>None</code> <code>color_map</code> <code>string, optional (default: 'Spectral')</code> <p>The name of the colormap to use if <code>color_list</code> is not provided. It will generate a set of colors for the different cell types.</p> <code>'Spectral'</code> <code>rotation_angle</code> <code>float, optional (default: None)</code> <p>An optional angle (in degrees) to rotate the spatial coordinates. If provided, the rotation is applied to the coordinates before plotting.</p> <code>None</code> <code>figsize</code> <code>tuple, optional (default: (2, 2))</code> <p>The size of the output figure, specified as a tuple of (width, height) in inches.</p> <code>(2, 2)</code> <p>Returns:</p> Type Description <code>None</code> <p>The function does not return any values but saves the generated pie chart plot as an SVG file in the specified <code>out_dir</code>.</p> Source code in <code>cytobulk\\plots\\_plot.py</code> <pre><code>def plot_celltype_fraction_pie(adata,\n                               scale_facter_x=1,\n                               scale_factor_y=1,\n                               r=0.1,\n                               out_dir='/plot',\n                               project_name='project',\n                               color_list=None,\n                               color_map=\"Spectral\",\n                               rotation_angle=None,\n                               figsize=(2, 2)):\n    \"\"\"\n    Plot cell type fraction as pie charts at spatial coordinates.\n\n    This function generates pie charts representing the cell type fraction at each spatial location (from the 'spatial' data in `adata`) and plots them on a 2D scatter plot. Each pie chart is positioned based on the spatial coordinates and reflects the relative abundance of each cell type at that spot. The resulting figure is saved as an SVG file.\n\n    Parameters\n    ----------\n    adata : anndata.AnnData\n        An :class:`~anndata.AnnData` object containing spatial transcriptomics data.\n        The spatial coordinates should be stored in `adata.obsm['spatial']`, and the deconvolution results (cell type fractions) should be stored in `adata.uns['deconv']`.\n\n    scale_facter_x : float, optional (default: 1)\n        A scaling factor to apply to the X-axis coordinates of the spatial data.\n\n    scale_factor_y : float, optional (default: 1)\n        A scaling factor to apply to the Y-axis coordinates of the spatial data.\n\n    r : float, optional (default: 0.1)\n        Radius of the pie charts representing cell type fractions at each spatial coordinate.\n\n    out_dir : string, optional (default: '/plot')\n        The directory where the output figure (SVG format) will be saved.\n\n    project_name : string, optional (default: 'project')\n        The prefix to use for the saved SVG file.\n\n    color_list : list, optional (default: None)\n        A list of colors to use for the cell types. If `None`, a colormap (specified by `color_map`) will be used to generate colors for each cell type.\n\n    color_map : string, optional (default: 'Spectral')\n        The name of the colormap to use if `color_list` is not provided. It will generate a set of colors for the different cell types.\n\n    rotation_angle : float, optional (default: None)\n        An optional angle (in degrees) to rotate the spatial coordinates. If provided, the rotation is applied to the coordinates before plotting.\n\n    figsize : tuple, optional (default: (2, 2))\n        The size of the output figure, specified as a tuple of (width, height) in inches.\n\n    Returns\n    -------\n    None\n        The function does not return any values but saves the generated pie chart plot as an SVG file in the specified `out_dir`.\n    \"\"\"\n    loc_xy=adata.obsm['spatial']\n    loc_xy=pd.DataFrame(loc_xy,columns=['x','y'],index=adata.obs_names)\n    if rotation_angle:\n        new_loc = loc_xy.apply(lambda x : utils.rotate_matrix(x['x'],x['y'],rotation_angle), axis=1)\n        loc_xy = pd.DataFrame(list(new_loc),columns=loc_xy.columns,index=loc_xy.index)\n    cell_type_fraction = adata.uns['deconv']\n    cell_type_fraction['None']=0\n    cell_type_fraction.loc[(cell_type_fraction==0).all(axis=1),\"None\"]=1\n    cell_type_fraction['x']=loc_xy['x']\n    cell_type_fraction['y']=loc_xy['y']\n    loc=cell_type_fraction\n    loc['max_idx'] = loc.iloc[:,:-2].idxmax(axis=1)\n    loc['x']=loc['x']/scale_facter_x\n    loc['y']=loc['y']/scale_factor_y\n    fig, ax = plt.subplots(figsize=figsize)\n    def _plot_pie(x, ax, color_sets,r): \n        fraction = x[:-3]\n        ax.pie(fraction, center=(x['x'],x['y']), radius=r,colors=[color_sets[key] for key in loc.columns[:-3]])\n        ax.set_title('CytoBulk',fontsize=20,x=1.2,y=1.7)\n    # git min/max values for the axes\n    cells = loc.columns[:-3].tolist()\n    if color_list:\n        color_dict = {item: color for item, color in zip(cells, color_list)}\n    else:\n        color_map = cm.get_cmap(color_map)\n        list_length = len(cells)\n        colors_list = [to_hex(color_map(i / (list_length - 1))) for i in range(list_length)]\n        color_dict = {item: color for item, color in zip(cells, colors_list)}\n\n    loc.apply(lambda x : _plot_pie(x, ax,color_dict,r=0.1), axis=1)\n\n    handles = []\n    for i, l in enumerate(cells):\n        handles.append(matplotlib.patches.Patch(color=colors_list[i], label=cells[i]))\n    plt.legend(handles,cells, bbox_to_anchor=(0.1,0.1),fontsize=12,markerscale=0.5,ncol=3,loc=\"upper left\")\n    fig.show()\n    fig.savefig(f\"{out_dir}/{project_name}_cell_fraction_pie.svg\", format=\"svg\", dpi=1200,bbox_inches = 'tight',transparent = True)\n</code></pre>"},{"location":"plots/_eval_plot/#cytobulk.plots._plot.plot_gene_similarity","title":"<code>plot_gene_similarity(adata, marker_df, custom_palette='Spectral')</code>","text":"<p>Compute and visualize cosine similarity for marker genes across cell types.</p> <p>This function calculates cosine similarity for marker genes between the gene expression matrix  and a mapping layer in an AnnData object. It generates a swarm plot to visualize the results  grouped by cell type.</p> <p>Parameters:</p> Name Type Description Default <code>adata</code> <code>AnnData</code> <p>An :class:<code>~anndata.AnnData</code> object containing gene expression data in <code>.X</code> and a mapping layer in <code>.layers[\"mapping_ori\"]</code>.</p> required <code>marker_df</code> <code>DataFrame</code> <p>DataFrame containing marker gene information. It must include the following columns: - 'gene_symbol': Gene symbol names. - 'cell_type': Cell type associated with the marker gene. - 'pvalue': P-value indicating marker significance. - 'score': Score representing the marker strength.</p> required <code>custom_palette</code> <code>str or list, optional (default: \"Spectral\")</code> <p>Custom color palette for plotting. Can be a string representing a seaborn palette or a list of colors.</p> <code>'Spectral'</code> <p>Returns:</p> Type Description <code>Figure</code> <p>A swarm plot showing cosine similarities for marker genes grouped by cell type.</p> Source code in <code>cytobulk\\plots\\_plot.py</code> <pre><code>def plot_gene_similarity(adata, marker_df, custom_palette=\"Spectral\"):\n    \"\"\"\n    Compute and visualize cosine similarity for marker genes across cell types.\n\n    This function calculates cosine similarity for marker genes between the gene expression matrix \n    and a mapping layer in an AnnData object. It generates a swarm plot to visualize the results \n    grouped by cell type.\n\n    Parameters\n    ----------\n    adata : anndata.AnnData\n        An :class:`~anndata.AnnData` object containing gene expression data in `.X` and a mapping layer in `.layers[\"mapping_ori\"]`.\n\n    marker_df : pandas.DataFrame\n        DataFrame containing marker gene information. It must include the following columns:\n        - 'gene_symbol': Gene symbol names.\n        - 'cell_type': Cell type associated with the marker gene.\n        - 'pvalue': P-value indicating marker significance.\n        - 'score': Score representing the marker strength.\n\n    custom_palette : str or list, optional (default: \"Spectral\")\n        Custom color palette for plotting. Can be a string representing a seaborn palette or a list of colors.\n\n    Returns\n    -------\n    matplotlib.pyplot.Figure\n        A swarm plot showing cosine similarities for marker genes grouped by cell type.\n    \"\"\"\n    # Access the gene expression matrix and mapping layer\n    import pandas as pd\n    import numpy as np\n    import scanpy as sc\n    from scipy.spatial.distance import cosine\n    import matplotlib.pyplot as plt\n    import seaborn as sns\n    mapping_ori = adata.layers[\"mapping_ori\"]  # Original mapping layer\n    adata_x = adata.X  # Main gene expression matrix\n\n    # Align gene symbols between the marker dataframe and the AnnData object\n    genes = adata.var.index.tolist()  # List of genes in AnnData\n    marker_genes = marker_df['gene_symbol'].tolist()  # List of marker genes\n    common_genes = list(set(marker_genes).intersection(genes))  # Find common genes\n\n    # Filter the marker DataFrame to only include the common genes\n    marker_df = marker_df[marker_df['gene_symbol'].isin(common_genes)]\n\n    # Initialize a list to store results for all cell types\n    all_results = []\n\n    # Group marker genes by cell type\n    for cell_type, group in marker_df.groupby(\"cell_type\"):\n        print(f\"Processing cell_type: {cell_type}\")\n\n        # Filter marker genes with p-value &lt; 0.05\n        filtered_group = group[group['pvalue'] &lt; 0.05]\n\n        # If more than 50 genes are available, select the top 50 based on the 'score' column\n        top_genes = filtered_group.nlargest(50, \"score\")\n\n        # Define a helper function to compute cosine similarity\n        def compute_cosine_similarity(gene_symbol, mapping_ori, adata_x, var_names):\n            \"\"\"\n            Compute cosine similarity for a given gene.\n\n            Parameters:\n            ----------\n            gene_symbol : str\n                The gene symbol to compute similarity for.\n            mapping_ori : np.ndarray\n                The original mapping layer array.\n            adata_x : np.ndarray\n                Gene expression matrix from AnnData.\n            var_names : list\n                List of gene names in AnnData.\n\n            Returns:\n            -------\n            float\n                Cosine similarity value or NaN if computation is not possible.\n            \"\"\"\n            # If the gene is not found in AnnData, return NaN\n            if gene_symbol not in var_names:\n                return np.nan\n\n            # Get the index of the gene in the AnnData object\n            gene_idx = var_names.index(gene_symbol)\n\n            # Extract expression vectors for the gene\n            gene_expression_vector = adata_x[:, gene_idx].flatten()  # Expression vector in adata.X\n            ori_vector = mapping_ori[:, gene_idx].flatten()  # Expression vector in mapping_ori\n\n            # Compute cosine similarity if vectors are non-zero\n            if np.any(gene_expression_vector) and np.any(ori_vector):\n                similarity = 1 - cosine(gene_expression_vector, ori_vector)\n            else:\n                similarity = np.nan  # Return NaN for zero vectors\n\n            return similarity\n\n        # Compute cosine similarity for each gene in the top genes\n        var_names = adata.var.index.tolist()  # Get gene names from AnnData\n        cosine_similarities = [\n            compute_cosine_similarity(gene_symbol, mapping_ori, adata.X, var_names)\n            for gene_symbol in top_genes[\"gene_symbol\"]\n        ]\n\n        # Add cosine similarity values to the DataFrame\n        top_genes[\"cosine_similarity\"] = cosine_similarities\n\n        # Append the results for the current cell type\n        all_results.append(top_genes)\n\n    # Concatenate results from all cell types into a single DataFrame\n    final_results = pd.concat(all_results, ignore_index=True)\n\n    # Use seaborn's default palette if no custom palette is provided\n  # Use seaborn's default color palette\n\n    # Create a Swarm Plot for cosine similarity grouped by cell type\n    plt.figure(figsize=(6, 4))  # Set the figure size to a smaller size (6x4 inches)\n    sns.swarmplot(\n        x=\"cell_type\", \n        y=\"cosine_similarity\", \n        data=final_results, \n        palette=custom_palette  # Use custom or default palette\n    )\n\n    # Add labels and customize the plot\n    plt.xlabel(\"Cell Type\", fontsize=12)\n    plt.ylabel(\"Cosine Similarity\", fontsize=12)\n    plt.xticks(fontsize=10)  # Adjust font size for x-axis labels\n    plt.tight_layout()  # Ensure the layout fits well\n\n    # Return the matplotlib.pyplot object for further customization or saving\n    return plt\n</code></pre>"},{"location":"plots/_eval_plot/#cytobulk.plots._plot.plot_he_cell_type","title":"<code>plot_he_cell_type(data, out_dir)</code>","text":"<p>Visualize and save a scatter plot of cell locations by cell type.</p> <p>This function generates a scatter plot to visualize the spatial distribution of different cell types  based on their x and y coordinates. The plot is customized with specific colors for predefined cell types  and is saved as a PNG file.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>DataFrame</code> <p>A pandas DataFrame containing the following columns: - 'cell_type': Categorical data representing cell types (e.g., \"Epithelial Cells\"). - 'x': Numerical values representing the x-coordinates of the cells. - 'y': Numerical values representing the y-coordinates of the cells.</p> required <code>out_dir</code> <code>str</code> <p>The directory where the generated plot image will be saved. The plot will be saved as  \"cell_type.png\" within this directory.</p> required <p>Returns:</p> Type Description <code>None</code> <p>This function does not return any values. It generates and saves the scatter plot as a PNG file.</p> Notes <ul> <li>The plot uses predefined colors for the following cell types:<ul> <li>\"Epithelial Cells\": #A52A2A (brown)</li> <li>\"Neutrophils\": #0000B8 (blue)</li> <li>\"Plasma Cells\": #0D98BA (cyan)</li> <li>\"Connective Tissue\": #FFCC33 (yellow)</li> <li>\"Lymphocytes\": #B284BE (purple)   Cell types not listed above are assigned the color \"black\".</li> </ul> </li> <li>The y-axis is inverted to match the typical orientation of spatial data.</li> </ul> Source code in <code>cytobulk\\plots\\_plot.py</code> <pre><code>def plot_he_cell_type(data,out_dir):\n    \"\"\"\n    Visualize and save a scatter plot of cell locations by cell type.\n\n    This function generates a scatter plot to visualize the spatial distribution of different cell types \n    based on their x and y coordinates. The plot is customized with specific colors for predefined cell types \n    and is saved as a PNG file.\n\n    Parameters\n    ----------\n    data : pandas.DataFrame\n        A pandas DataFrame containing the following columns:\n        - 'cell_type': Categorical data representing cell types (e.g., \"Epithelial Cells\").\n        - 'x': Numerical values representing the x-coordinates of the cells.\n        - 'y': Numerical values representing the y-coordinates of the cells.\n\n    out_dir : str\n        The directory where the generated plot image will be saved. The plot will be saved as \n        \"cell_type.png\" within this directory.\n\n    Returns\n    -------\n    None\n        This function does not return any values. It generates and saves the scatter plot as a PNG file.\n\n    Notes\n    -----\n    - The plot uses predefined colors for the following cell types:\n        * \"Epithelial Cells\": #A52A2A (brown)\n        * \"Neutrophils\": #0000B8 (blue)\n        * \"Plasma Cells\": #0D98BA (cyan)\n        * \"Connective Tissue\": #FFCC33 (yellow)\n        * \"Lymphocytes\": #B284BE (purple)\n      Cell types not listed above are assigned the color \"black\".\n    - The y-axis is inverted to match the typical orientation of spatial data.\n    \"\"\"\n    import pandas as pd\n    import matplotlib.pyplot as plt\n\n    categories = data[\"cell_type\"].unique()\n    colors = {\n        \"Epithelial Cells\": \"#A52A2A\",  \n        \"Neutrophils\": \"#0000B8\",      \n        \"Plasma Cells\": \"#0D98BA\",     \n        \"Connective Tissue\": \"#FFCC33\", \n        \"Lymphocytes\": \"#B284BE\"      \n    }\n\n    plt.figure(figsize=(4, 4))\n\n    for category in categories:\n        subset = data[data[\"cell_type\"] == category]\n        plt.scatter(subset[\"x\"], subset[\"y\"], label=category, color=colors.get(category, \"black\"), s=10, alpha=0.8)\n    plt.legend(\n        loc=\"upper right\",             # Place the legend in the top-right corner\n        title=\"Cell Types\",            # Add a title to the legend\n        fontsize=8,                    # Set font size for the legend labels\n        title_fontsize=10,             # Set font size for the legend title\n        markerscale=1.5                # Scale the legend markers (scatter points)\n    )\n\n\n    plt.gca().axis(\"off\")\n    plt.gca().invert_yaxis()\n    save_path = f\"{out_dir}/cell_type.png\"\n    plt.tight_layout()\n    plt.savefig(save_path, dpi=300, bbox_inches=\"tight\", pad_inches=0) \n    plt.show()\n</code></pre>"},{"location":"plots/_eval_plot/#cytobulk.plots._plot.plot_paired_violin","title":"<code>plot_paired_violin(adata, label, gene, stats_method='spearmanr', out_dir='/plot', color_list=Const.DIFF_COLOR_N, project_name='test', figsize=(6, 4), ylim=[-0.1, 1.2])</code>","text":"<p>Plot paired violin plots for gene expression and predicted cell type fractions.</p> <p>This function generates paired violin plots comparing the expression of a specific gene with the predicted cell type fraction (from deconvolution data) for the same set of observations. It also computes a statistical correlation (Spearman or Pearson) between the gene expression and the predicted cell type fractions and displays the correlation coefficient and significance on the plot.</p> <p>Parameters:</p> Name Type Description Default <code>adata</code> <code>AnnData</code> <p>An :class:<code>~anndata.AnnData</code> object containing gene expression data and the output of a cell type deconvolution. - Gene expression data should be stored in <code>adata.X</code> with cell/barcode names in <code>adata.obs_names</code> and gene names in <code>adata.var_names</code>. - Predicted cell type fractions (from deconvolution) should be stored in <code>adata.uns['deconv']</code>.</p> required <code>label</code> <code>string</code> <p>The name of the cell type (as stored in <code>adata.uns['deconv']</code>) to be compared against the gene expression.</p> required <code>gene</code> <code>string</code> <p>The name of the gene (as stored in <code>adata.var_names</code>) whose expression levels will be compared to the predicted cell type fractions.</p> required <code>stats_method</code> <code>string, optional (default: 'spearmanr')</code> <p>The statistical method used to compute the correlation between gene expression and predicted cell type fractions. - <code>'spearmanr'</code>: Spearman\u2019s rank correlation. - <code>'pearsonr'</code>: Pearson\u2019s correlation.</p> <code>'spearmanr'</code> <code>out_dir</code> <code>string, optional (default: '/plot')</code> <p>The directory where the output violin plot (SVG format) will be saved.</p> <code>'/plot'</code> <code>color_list</code> <code>list, optional (default: Const.DIFF_COLOR_N)</code> <p>A list of colors to use for the violin plots. If not provided, a default color palette will be used.</p> <code>DIFF_COLOR_N</code> <code>project_name</code> <code>string, optional (default: 'test')</code> <p>The prefix to use for the saved SVG file.</p> <code>'test'</code> <code>figsize</code> <code>tuple, optional (default: (6, 4))</code> <p>The size of the output figure, specified as a tuple of (width, height) in inches.</p> <code>(6, 4)</code> <code>ylim</code> <code>list, optional (default: [-0.1, 1.2])</code> <p>The limits for the Y-axis of the violin plot. This should be a list of two values [min, max].</p> <code>[-0.1, 1.2]</code> <p>Returns:</p> Type Description <code>None</code> <p>The function does not return any values but saves the generated violin plot as an SVG file in the specified <code>out_dir</code>.</p> Source code in <code>cytobulk\\plots\\_plot.py</code> <pre><code>def plot_paired_violin(adata,\n                       label,\n                       gene,\n                       stats_method='spearmanr',\n                       out_dir='/plot',\n                       color_list=Const.DIFF_COLOR_N,\n                       project_name=\"test\",\n                       figsize=(6, 4),\n                       ylim=[-0.1, 1.2]):\n    \"\"\"\n    Plot paired violin plots for gene expression and predicted cell type fractions.\n\n    This function generates paired violin plots comparing the expression of a specific gene with the predicted cell type fraction (from deconvolution data) for the same set of observations. It also computes a statistical correlation (Spearman or Pearson) between the gene expression and the predicted cell type fractions and displays the correlation coefficient and significance on the plot.\n\n    Parameters\n    ----------\n    adata : anndata.AnnData\n        An :class:`~anndata.AnnData` object containing gene expression data and the output of a cell type deconvolution.\n        - Gene expression data should be stored in `adata.X` with cell/barcode names in `adata.obs_names` and gene names in `adata.var_names`.\n        - Predicted cell type fractions (from deconvolution) should be stored in `adata.uns['deconv']`.\n\n    label : string\n        The name of the cell type (as stored in `adata.uns['deconv']`) to be compared against the gene expression.\n\n    gene : string\n        The name of the gene (as stored in `adata.var_names`) whose expression levels will be compared to the predicted cell type fractions.\n\n    stats_method : string, optional (default: 'spearmanr')\n        The statistical method used to compute the correlation between gene expression and predicted cell type fractions.\n        - `'spearmanr'`: Spearman\u2019s rank correlation.\n        - `'pearsonr'`: Pearson\u2019s correlation.\n\n    out_dir : string, optional (default: '/plot')\n        The directory where the output violin plot (SVG format) will be saved.\n\n    color_list : list, optional (default: Const.DIFF_COLOR_N)\n        A list of colors to use for the violin plots. If not provided, a default color palette will be used.\n\n    project_name : string, optional (default: 'test')\n        The prefix to use for the saved SVG file.\n\n    figsize : tuple, optional (default: (6, 4))\n        The size of the output figure, specified as a tuple of (width, height) in inches.\n\n    ylim : list, optional (default: [-0.1, 1.2])\n        The limits for the Y-axis of the violin plot. This should be a list of two values [min, max].\n\n    Returns\n    -------\n    None\n        The function does not return any values but saves the generated violin plot as an SVG file in the specified `out_dir`.\n    \"\"\"\n    from scipy import stats\n    from sklearn.preprocessing import minmax_scale\n    fig = plt.figure(figsize=figsize)\n    color_panel = sns.set_palette(color_list)\n    name_list=[]\n    value_list=[]\n    exp_data = pd.DataFrame(adata.X,index=adata.obs_names,columns=adata.var_names)\n    predicted = adata.uns['deconv']\n    common_label=exp_data.index.intersection(predicted.index)\n    predicted=predicted.loc[common_label,:]\n    exp_data=exp_data.loc[common_label,:]\n    exp_data[gene] = minmax_scale((exp_data[gene]), feature_range=(0, 1))\n    predicted[label] = minmax_scale(predicted[label], feature_range=(0, 1))\n    if stats_method=='spearmanr':\n        stat,p_value = stats.spearmanr(exp_data[gene],predicted[label])\n    else:\n        stat,p_value = stats.pearsonr(exp_data[gene],predicted[label])\n    p_value=utils.convert_pvalue_to_asterisks(p_value)\n    value_list.extend(exp_data[gene].values)\n    name_list.extend([gene]*len(exp_data[gene].values))\n    value_list.extend(predicted[label])\n    name_list.extend([label]*len(predicted[label]))\n    input_data=pd.DataFrame.from_dict({'source':name_list,'value':value_list})\n    ax = sns.violinplot(x=\"source\",y=\"value\",data=input_data,hue='source',palette=color_panel)\n    x1, x2 = 0, 1\n    y,h = predicted[label].max()+.1,.1\n    ax.plot([x1, x1, x2, x2], [y, y+h, y+h, y], lw=1, c=\"k\") \n    ax.text((x1+x2)*.5, y+h, stats_method+\": \"+ str(\"%.2f\" % stat) +\" \"+  p_value, ha='center', va='bottom', color=\"k\",fontsize=14)\n    ax.set_ylim([-0.3, 1.5])\n    ax.tick_params(which='major',direction='in',length=3,width=1.,labelsize=14,bottom=False)\n    plt.savefig(f\"{out_dir}/{project_name}_{label}_{gene}_violin.svg\", format=\"svg\", dpi=1200,bbox_inches = 'tight',transparent = True)\n</code></pre>"},{"location":"plots/_eval_plot/#cytobulk.plots._plot.plot_reconstruction","title":"<code>plot_reconstruction(adata, out_dir, project_name='test', rotation_angle=None, spot_size=0.5)</code>","text":"<p>Plot reconstructed spatial transcriptomics data with correlation analysis.</p> <p>This function computes the Pearson correlation between the original and reconstructed spatial transcriptomics data for each spot. It then visualizes the spatial distribution of correlation coefficients using a scatter plot.</p> <p>Parameters:</p> Name Type Description Default <code>adata</code> <code>AnnData</code> <p>An :class:<code>~anndata.AnnData</code> object containing the spatial transcriptomics data. - Original data should be in <code>adata.layers['original_st']</code>. - Reconstructed data should be in <code>adata.X</code>. - Spatial coordinates should be in <code>adata.obsm['spatial']</code>.</p> required <code>out_dir</code> <code>string</code> <p>The directory where the output plot (SVG format) will be saved.</p> required <code>project_name</code> <code>string, optional (default: 'test')</code> <p>The prefix to use for the saved SVG file.</p> <code>'test'</code> <code>rotation_angle</code> <code>float</code> <p>The angle to rotate the spatial coordinates, if any.</p> <code>None</code> <code>spot_size</code> <code>float, optional (default: 0.5)</code> <p>The size of the spots in the scatter plot.</p> <code>0.5</code> <p>Returns:</p> Type Description <code>None</code> <p>The function does not return any values but saves the generated scatter plot as an SVG file in the specified <code>out_dir</code>.</p> Source code in <code>cytobulk\\plots\\_plot.py</code> <pre><code>def plot_reconstruction(adata,\n                        out_dir,\n                        project_name=\"test\",\n                        rotation_angle=None,\n                        spot_size=0.5):\n    \"\"\"\n    Plot reconstructed spatial transcriptomics data with correlation analysis.\n\n    This function computes the Pearson correlation between the original and reconstructed spatial transcriptomics data for each spot. It then visualizes the spatial distribution of correlation coefficients using a scatter plot.\n\n    Parameters\n    ----------\n    adata : anndata.AnnData\n        An :class:`~anndata.AnnData` object containing the spatial transcriptomics data.\n        - Original data should be in `adata.layers['original_st']`.\n        - Reconstructed data should be in `adata.X`.\n        - Spatial coordinates should be in `adata.obsm['spatial']`.\n\n    out_dir : string\n        The directory where the output plot (SVG format) will be saved.\n\n    project_name : string, optional (default: 'test')\n        The prefix to use for the saved SVG file.\n\n    rotation_angle : float, optional\n        The angle to rotate the spatial coordinates, if any.\n\n    spot_size : float, optional (default: 0.5)\n        The size of the spots in the scatter plot.\n\n    Returns\n    -------\n    None\n        The function does not return any values but saves the generated scatter plot as an SVG file in the specified `out_dir`.\n    \"\"\"\n    from scipy.stats import pearsonr\n    adata.var_names_make_unique()\n    # Calculate Pearson correlation and p-value for each sample (row)\n    loc_xy=adata.obsm['spatial']\n    loc_xy=pd.DataFrame(loc_xy,columns=['x','y'],index=adata.obs_names)\n    if rotation_angle:\n        new_loc = loc_xy.apply(lambda x : utils.rotate_matrix(x['x'],x['y'],rotation_angle), axis=1)\n        loc_xy = pd.DataFrame(list(new_loc),columns=loc_xy.columns,index=loc_xy.index)\n\n    results = []\n    for i in range(adata.shape[0]):  # Loop through each sample\n        r, p = pearsonr(adata.layers['original_st'][i], adata.X[i])\n        results.append((i, r, p))  # Store index, Pearson r, and p-value\n\n    # Convert results to a DataFrame\n    results_df = pd.DataFrame(results, columns=['spot', 'Pearson R', 'pvalue'])\n    results_df.set_index('spot',inplace=True)\n    adata.obsm['spatial']=loc_xy.values\n    adata.obs = results_df\n    average_corr = round(np.mean(results_df['Pearson R']),3)\n\n    fig=sc.pl.spatial(\n        adata,\n        color='Pearson R',\n        img_key=None,\n        alpha=0.8,\n        color_map=\"mako_r\",\n        size=1.5,\n        title=f'Reconstructed ST\\nmean Pearson correlation = {average_corr}\\ngene number = {len(adata.var_names)}',\n        frameon=False,\n        spot_size=spot_size,\n        outline_width=0,\n        return_fig=True\n    )\n    plt.savefig(f\"{out_dir}/{project_name}_reconstructed_correlation.svg\", format=\"svg\", dpi=1200,bbox_inches = 'tight',transparent = True)\n</code></pre>"},{"location":"plots/_plot/","title":"plots._plot","text":"<p><pre><code>plot_celltype_fraction_pie(adata,\n                               scale_facter_x=1,\n                               scale_factor_y=1,\n                               r=0.1,\n                               out_dir='/plot',\n                               project_name='project',\n                               color_list=None,\n                               color_map=\"Spectral\",\n                               rotation_angle=None,\n                               figsize=(2, 2))\n</code></pre> </p> <p>Plot cell type fraction as pie charts at spatial coordinates.</p> <p>This function generates pie charts representing the cell type fraction at each spatial location (from the 'spatial' data in <code>adata</code>) and plots them on a 2D scatter plot. Each pie chart is positioned based on the spatial coordinates and reflects the relative abundance of each cell type at that spot. The resulting figure is saved as an SVG file.</p> <p>Parameters:</p> Name Type Description Default <code>adata</code> <code>AnnData</code> <p>An :class:<code>~anndata.AnnData</code> object containing spatial transcriptomics data. The spatial coordinates should be stored in <code>adata.obsm['spatial']</code>, and the deconvolution results (cell type fractions) should be stored in <code>adata.uns['deconv']</code>.</p> required <code>scale_facter_x</code> <code>float, optional (default: 1)</code> <p>A scaling factor to apply to the X-axis coordinates of the spatial data.</p> <code>1</code> <code>scale_factor_y</code> <code>float, optional (default: 1)</code> <p>A scaling factor to apply to the Y-axis coordinates of the spatial data.</p> <code>1</code> <code>r</code> <code>float, optional (default: 0.1)</code> <p>Radius of the pie charts representing cell type fractions at each spatial coordinate.</p> <code>0.1</code> <code>out_dir</code> <code>string, optional (default: '/plot')</code> <p>The directory where the output figure (SVG format) will be saved.</p> <code>'/plot'</code> <code>project_name</code> <code>string, optional (default: 'project')</code> <p>The prefix to use for the saved SVG file.</p> <code>'project'</code> <code>color_list</code> <code>list, optional (default: None)</code> <p>A list of colors to use for the cell types. If <code>None</code>, a colormap (specified by <code>color_map</code>) will be used to generate colors for each cell type.</p> <code>None</code> <code>color_map</code> <code>string, optional (default: 'Spectral')</code> <p>The name of the colormap to use if <code>color_list</code> is not provided. It will generate a set of colors for the different cell types.</p> <code>'Spectral'</code> <code>rotation_angle</code> <code>float, optional (default: None)</code> <p>An optional angle (in degrees) to rotate the spatial coordinates. If provided, the rotation is applied to the coordinates before plotting.</p> <code>None</code> <code>figsize</code> <code>tuple, optional (default: (2, 2))</code> <p>The size of the output figure, specified as a tuple of (width, height) in inches.</p> <code>(2, 2)</code> <p>Returns:</p> Type Description <code>None</code> <p>The function does not return any values but saves the generated pie chart plot as an SVG file in the specified <code>out_dir</code>.</p> Source code in <code>cytobulk\\plots\\_plot.py</code> <pre><code>def plot_celltype_fraction_pie(adata,\n                               scale_facter_x=1,\n                               scale_factor_y=1,\n                               r=0.1,\n                               out_dir='/plot',\n                               project_name='project',\n                               color_list=None,\n                               color_map=\"Spectral\",\n                               rotation_angle=None,\n                               figsize=(2, 2)):\n    \"\"\"\n    Plot cell type fraction as pie charts at spatial coordinates.\n\n    This function generates pie charts representing the cell type fraction at each spatial location (from the 'spatial' data in `adata`) and plots them on a 2D scatter plot. Each pie chart is positioned based on the spatial coordinates and reflects the relative abundance of each cell type at that spot. The resulting figure is saved as an SVG file.\n\n    Parameters\n    ----------\n    adata : anndata.AnnData\n        An :class:`~anndata.AnnData` object containing spatial transcriptomics data.\n        The spatial coordinates should be stored in `adata.obsm['spatial']`, and the deconvolution results (cell type fractions) should be stored in `adata.uns['deconv']`.\n\n    scale_facter_x : float, optional (default: 1)\n        A scaling factor to apply to the X-axis coordinates of the spatial data.\n\n    scale_factor_y : float, optional (default: 1)\n        A scaling factor to apply to the Y-axis coordinates of the spatial data.\n\n    r : float, optional (default: 0.1)\n        Radius of the pie charts representing cell type fractions at each spatial coordinate.\n\n    out_dir : string, optional (default: '/plot')\n        The directory where the output figure (SVG format) will be saved.\n\n    project_name : string, optional (default: 'project')\n        The prefix to use for the saved SVG file.\n\n    color_list : list, optional (default: None)\n        A list of colors to use for the cell types. If `None`, a colormap (specified by `color_map`) will be used to generate colors for each cell type.\n\n    color_map : string, optional (default: 'Spectral')\n        The name of the colormap to use if `color_list` is not provided. It will generate a set of colors for the different cell types.\n\n    rotation_angle : float, optional (default: None)\n        An optional angle (in degrees) to rotate the spatial coordinates. If provided, the rotation is applied to the coordinates before plotting.\n\n    figsize : tuple, optional (default: (2, 2))\n        The size of the output figure, specified as a tuple of (width, height) in inches.\n\n    Returns\n    -------\n    None\n        The function does not return any values but saves the generated pie chart plot as an SVG file in the specified `out_dir`.\n    \"\"\"\n    loc_xy=adata.obsm['spatial']\n    loc_xy=pd.DataFrame(loc_xy,columns=['x','y'],index=adata.obs_names)\n    if rotation_angle:\n        new_loc = loc_xy.apply(lambda x : utils.rotate_matrix(x['x'],x['y'],rotation_angle), axis=1)\n        loc_xy = pd.DataFrame(list(new_loc),columns=loc_xy.columns,index=loc_xy.index)\n    cell_type_fraction = adata.uns['deconv']\n    cell_type_fraction['None']=0\n    cell_type_fraction.loc[(cell_type_fraction==0).all(axis=1),\"None\"]=1\n    cell_type_fraction['x']=loc_xy['x']\n    cell_type_fraction['y']=loc_xy['y']\n    loc=cell_type_fraction\n    loc['max_idx'] = loc.iloc[:,:-2].idxmax(axis=1)\n    loc['x']=loc['x']/scale_facter_x\n    loc['y']=loc['y']/scale_factor_y\n    fig, ax = plt.subplots(figsize=figsize)\n    def _plot_pie(x, ax, color_sets,r): \n        fraction = x[:-3]\n        ax.pie(fraction, center=(x['x'],x['y']), radius=r,colors=[color_sets[key] for key in loc.columns[:-3]])\n        ax.set_title('CytoBulk',fontsize=20,x=1.2,y=1.7)\n    # git min/max values for the axes\n    cells = loc.columns[:-3].tolist()\n    if color_list:\n        color_dict = {item: color for item, color in zip(cells, color_list)}\n    else:\n        color_map = cm.get_cmap(color_map)\n        list_length = len(cells)\n        colors_list = [to_hex(color_map(i / (list_length - 1))) for i in range(list_length)]\n        color_dict = {item: color for item, color in zip(cells, colors_list)}\n\n    loc.apply(lambda x : _plot_pie(x, ax,color_dict,r=0.1), axis=1)\n\n    handles = []\n    for i, l in enumerate(cells):\n        handles.append(matplotlib.patches.Patch(color=colors_list[i], label=cells[i]))\n    plt.legend(handles,cells, bbox_to_anchor=(0.1,0.1),fontsize=12,markerscale=0.5,ncol=3,loc=\"upper left\")\n    fig.show()\n    fig.savefig(f\"{out_dir}/{project_name}_cell_fraction_pie.svg\", format=\"svg\", dpi=1200,bbox_inches = 'tight',transparent = True)\n</code></pre> <p><pre><code>plot_celltype_fraction_heatmap(adata,\n                                   label,\n                                    r=0.1,\n                                    out_dir='/plot',\n                                    project_name='project',\n                                    color_map='crest',\n                                    rotation_angle=None,\n                                    figsize=(2.7, 2))\n</code></pre> </p> <p>Plot a heatmap of cell type fractions at spatial coordinates.</p> <p>This function visualizes the fraction of a specified cell type as a heatmap on a 2D scatter plot, using spatial transcriptomics data. The color intensity of each point corresponds to the cell type fraction at that spatial location. The resulting figure is saved as an SVG file.</p> <p>Parameters:</p> Name Type Description Default <code>adata</code> <code>AnnData</code> <p>An :class:<code>~anndata.AnnData</code> object containing spatial transcriptomics data. The spatial coordinates should be stored in <code>adata.obsm['spatial']</code>, and the deconvolution results (cell type fractions) should be stored in <code>adata.uns['deconv']</code>.</p> required <code>label</code> <code>string</code> <p>The name of the cell type to plot. This should correspond to one of the columns in <code>adata.uns['deconv']</code>, which represents the fractions of different cell types.</p> required <code>r</code> <code>float, optional (default: 0.1)</code> <p>Radius of the points representing the cell type fractions at each spatial coordinate.</p> <code>0.1</code> <code>out_dir</code> <code>string, optional (default: '/plot')</code> <p>The directory where the output figure (SVG format) will be saved.</p> <code>'/plot'</code> <code>project_name</code> <code>string, optional (default: 'project')</code> <p>The prefix to use for the saved SVG file.</p> <code>'project'</code> <code>color_map</code> <code>string, optional (default: 'crest')</code> <p>The name of the colormap to use for the heatmap. This can be any colormap recognized by <code>seaborn</code> or <code>matplotlib</code>.</p> <code>'crest'</code> <code>rotation_angle</code> <code>float, optional (default: None)</code> <p>An optional angle (in degrees) to rotate the spatial coordinates. If provided, the rotation is applied to the coordinates before plotting.</p> <code>None</code> <code>figsize</code> <code>tuple, optional (default: (2.7, 2))</code> <p>The size of the output figure, specified as a tuple of (width, height) in inches.</p> <code>(2.7, 2)</code> <p>Returns:</p> Type Description <code>None</code> <p>The function does not return any values but saves the generated heatmap plot as an SVG file in the specified <code>out_dir</code>.</p> Source code in <code>cytobulk\\plots\\_plot.py</code> <pre><code>def plot_celltype_fraction_heatmap(adata,\n                                   label,\n                                    r=0.1,\n                                    out_dir='/plot',\n                                    project_name='project',\n                                    color_map='crest',\n                                    rotation_angle=None,\n                                    figsize=(2.7, 2)):\n    \"\"\"\n    Plot a heatmap of cell type fractions at spatial coordinates.\n\n    This function visualizes the fraction of a specified cell type as a heatmap on a 2D scatter plot, using spatial transcriptomics data. The color intensity of each point corresponds to the cell type fraction at that spatial location. The resulting figure is saved as an SVG file.\n\n    Parameters\n    ----------\n    adata : anndata.AnnData\n        An :class:`~anndata.AnnData` object containing spatial transcriptomics data.\n        The spatial coordinates should be stored in `adata.obsm['spatial']`, and the deconvolution results (cell type fractions) should be stored in `adata.uns['deconv']`.\n\n    label : string\n        The name of the cell type to plot. This should correspond to one of the columns in `adata.uns['deconv']`, which represents the fractions of different cell types.\n\n    r : float, optional (default: 0.1)\n        Radius of the points representing the cell type fractions at each spatial coordinate.\n\n    out_dir : string, optional (default: '/plot')\n        The directory where the output figure (SVG format) will be saved.\n\n    project_name : string, optional (default: 'project')\n        The prefix to use for the saved SVG file.\n\n    color_map : string, optional (default: 'crest')\n        The name of the colormap to use for the heatmap. This can be any colormap recognized by `seaborn` or `matplotlib`.\n\n    rotation_angle : float, optional (default: None)\n        An optional angle (in degrees) to rotate the spatial coordinates. If provided, the rotation is applied to the coordinates before plotting.\n\n    figsize : tuple, optional (default: (2.7, 2))\n        The size of the output figure, specified as a tuple of (width, height) in inches.\n\n    Returns\n    -------\n    None\n        The function does not return any values but saves the generated heatmap plot as an SVG file in the specified `out_dir`.\n    \"\"\"\n    from sklearn.preprocessing import minmax_scale\n    fig, ax = plt.subplots(figsize=figsize)\n    plt.xticks([])\n    plt.yticks([])\n    plt.axis('off')\n    loc_xy=adata.obsm['spatial']\n    loc_xy=pd.DataFrame(loc_xy,columns=['x','y'],index=adata.obs_names)\n    if rotation_angle:\n        new_loc = loc_xy.apply(lambda x : utils.rotate_matrix(x['x'],x['y'],rotation_angle), axis=1)\n        loc_xy = pd.DataFrame(list(new_loc),columns=loc_xy.columns,index=loc_xy.index)\n    cell_type_fraction = adata.uns['deconv']\n    cell_type_fraction['x']=loc_xy['x']\n    cell_type_fraction['y']=loc_xy['y']\n    cell_type_fraction[label] = minmax_scale(cell_type_fraction[label].values)\n    sns.scatterplot(data=cell_type_fraction, x=\"x\", y=\"y\",palette=color_map,hue=label,s=20,legend=False,edgecolor=\"None\",markers=\"pentagon\")\n    norm = plt.Normalize(cell_type_fraction[label].min(), cell_type_fraction[label].max())\n    cmap = sns.color_palette(color_map, as_cmap=True)\n    sm = plt.cm.ScalarMappable(cmap=cmap, norm=norm)\n    sm.set_array([])\n    cax = fig.add_axes([ax.get_position().x1+0.05, ax.get_position().y0, 0.03, ax.get_position().height])\n    ax.set_title(f'{label}',fontsize=10,x=ax.get_position().x1/2,y=ax.get_position().y1+0.1)\n    ax.figure.colorbar(sm, cax=cax)\n    fig.show()\n    fig.savefig(f\"{out_dir}/{project_name}_{label}.svg\", format=\"svg\", dpi=1200,bbox_inches = 'tight',transparent = True)\n</code></pre> <p><pre><code>plot_paired_violin(adata,\n                       label,\n                       gene,\n                       stats_method='spearmanr',\n                       out_dir='/plot',\n                       color_list=Const.DIFF_COLOR_N,\n                       project_name=\"test\",\n                       figsize=(6, 4),\n                       ylim=[-0.1, 1.2])\n</code></pre> </p> <p>Plot paired violin plots for gene expression and predicted cell type fractions.</p> <p>This function generates paired violin plots comparing the expression of a specific gene with the predicted cell type fraction (from deconvolution data) for the same set of observations. It also computes a statistical correlation (Spearman or Pearson) between the gene expression and the predicted cell type fractions and displays the correlation coefficient and significance on the plot.</p> <p>Parameters:</p> Name Type Description Default <code>adata</code> <code>AnnData</code> <p>An :class:<code>~anndata.AnnData</code> object containing gene expression data and the output of a cell type deconvolution. - Gene expression data should be stored in <code>adata.X</code> with cell/barcode names in <code>adata.obs_names</code> and gene names in <code>adata.var_names</code>. - Predicted cell type fractions (from deconvolution) should be stored in <code>adata.uns['deconv']</code>.</p> required <code>label</code> <code>string</code> <p>The name of the cell type (as stored in <code>adata.uns['deconv']</code>) to be compared against the gene expression.</p> required <code>gene</code> <code>string</code> <p>The name of the gene (as stored in <code>adata.var_names</code>) whose expression levels will be compared to the predicted cell type fractions.</p> required <code>stats_method</code> <code>string, optional (default: 'spearmanr')</code> <p>The statistical method used to compute the correlation between gene expression and predicted cell type fractions. - <code>'spearmanr'</code>: Spearman\u2019s rank correlation. - <code>'pearsonr'</code>: Pearson\u2019s correlation.</p> <code>'spearmanr'</code> <code>out_dir</code> <code>string, optional (default: '/plot')</code> <p>The directory where the output violin plot (SVG format) will be saved.</p> <code>'/plot'</code> <code>color_list</code> <code>list, optional (default: Const.DIFF_COLOR_N)</code> <p>A list of colors to use for the violin plots. If not provided, a default color palette will be used.</p> <code>DIFF_COLOR_N</code> <code>project_name</code> <code>string, optional (default: 'test')</code> <p>The prefix to use for the saved SVG file.</p> <code>'test'</code> <code>figsize</code> <code>tuple, optional (default: (6, 4))</code> <p>The size of the output figure, specified as a tuple of (width, height) in inches.</p> <code>(6, 4)</code> <code>ylim</code> <code>list, optional (default: [-0.1, 1.2])</code> <p>The limits for the Y-axis of the violin plot. This should be a list of two values [min, max].</p> <code>[-0.1, 1.2]</code> <p>Returns:</p> Type Description <code>None</code> <p>The function does not return any values but saves the generated violin plot as an SVG file in the specified <code>out_dir</code>.</p> Source code in <code>cytobulk\\plots\\_plot.py</code> <pre><code>def plot_paired_violin(adata,\n                       label,\n                       gene,\n                       stats_method='spearmanr',\n                       out_dir='/plot',\n                       color_list=Const.DIFF_COLOR_N,\n                       project_name=\"test\",\n                       figsize=(6, 4),\n                       ylim=[-0.1, 1.2]):\n    \"\"\"\n    Plot paired violin plots for gene expression and predicted cell type fractions.\n\n    This function generates paired violin plots comparing the expression of a specific gene with the predicted cell type fraction (from deconvolution data) for the same set of observations. It also computes a statistical correlation (Spearman or Pearson) between the gene expression and the predicted cell type fractions and displays the correlation coefficient and significance on the plot.\n\n    Parameters\n    ----------\n    adata : anndata.AnnData\n        An :class:`~anndata.AnnData` object containing gene expression data and the output of a cell type deconvolution.\n        - Gene expression data should be stored in `adata.X` with cell/barcode names in `adata.obs_names` and gene names in `adata.var_names`.\n        - Predicted cell type fractions (from deconvolution) should be stored in `adata.uns['deconv']`.\n\n    label : string\n        The name of the cell type (as stored in `adata.uns['deconv']`) to be compared against the gene expression.\n\n    gene : string\n        The name of the gene (as stored in `adata.var_names`) whose expression levels will be compared to the predicted cell type fractions.\n\n    stats_method : string, optional (default: 'spearmanr')\n        The statistical method used to compute the correlation between gene expression and predicted cell type fractions.\n        - `'spearmanr'`: Spearman\u2019s rank correlation.\n        - `'pearsonr'`: Pearson\u2019s correlation.\n\n    out_dir : string, optional (default: '/plot')\n        The directory where the output violin plot (SVG format) will be saved.\n\n    color_list : list, optional (default: Const.DIFF_COLOR_N)\n        A list of colors to use for the violin plots. If not provided, a default color palette will be used.\n\n    project_name : string, optional (default: 'test')\n        The prefix to use for the saved SVG file.\n\n    figsize : tuple, optional (default: (6, 4))\n        The size of the output figure, specified as a tuple of (width, height) in inches.\n\n    ylim : list, optional (default: [-0.1, 1.2])\n        The limits for the Y-axis of the violin plot. This should be a list of two values [min, max].\n\n    Returns\n    -------\n    None\n        The function does not return any values but saves the generated violin plot as an SVG file in the specified `out_dir`.\n    \"\"\"\n    from scipy import stats\n    from sklearn.preprocessing import minmax_scale\n    fig = plt.figure(figsize=figsize)\n    color_panel = sns.set_palette(color_list)\n    name_list=[]\n    value_list=[]\n    exp_data = pd.DataFrame(adata.X,index=adata.obs_names,columns=adata.var_names)\n    predicted = adata.uns['deconv']\n    common_label=exp_data.index.intersection(predicted.index)\n    predicted=predicted.loc[common_label,:]\n    exp_data=exp_data.loc[common_label,:]\n    exp_data[gene] = minmax_scale((exp_data[gene]), feature_range=(0, 1))\n    predicted[label] = minmax_scale(predicted[label], feature_range=(0, 1))\n    if stats_method=='spearmanr':\n        stat,p_value = stats.spearmanr(exp_data[gene],predicted[label])\n    else:\n        stat,p_value = stats.pearsonr(exp_data[gene],predicted[label])\n    p_value=utils.convert_pvalue_to_asterisks(p_value)\n    value_list.extend(exp_data[gene].values)\n    name_list.extend([gene]*len(exp_data[gene].values))\n    value_list.extend(predicted[label])\n    name_list.extend([label]*len(predicted[label]))\n    input_data=pd.DataFrame.from_dict({'source':name_list,'value':value_list})\n    ax = sns.violinplot(x=\"source\",y=\"value\",data=input_data,hue='source',palette=color_panel)\n    x1, x2 = 0, 1\n    y,h = predicted[label].max()+.1,.1\n    ax.plot([x1, x1, x2, x2], [y, y+h, y+h, y], lw=1, c=\"k\") \n    ax.text((x1+x2)*.5, y+h, stats_method+\": \"+ str(\"%.2f\" % stat) +\" \"+  p_value, ha='center', va='bottom', color=\"k\",fontsize=14)\n    ax.set_ylim([-0.3, 1.5])\n    ax.tick_params(which='major',direction='in',length=3,width=1.,labelsize=14,bottom=False)\n    plt.savefig(f\"{out_dir}/{project_name}_{label}_{gene}_violin.svg\", format=\"svg\", dpi=1200,bbox_inches = 'tight',transparent = True)\n</code></pre> <p><pre><code>def plot_reconstruction(adata,\n                        out_dir,\n                        project_name=\"test\",\n                        rotation_angle=None,\n                        spot_size=0.5):\n</code></pre> </p> <p>Plot reconstructed spatial transcriptomics data with correlation analysis.</p> <p>This function computes the Pearson correlation between the original and reconstructed spatial transcriptomics data for each spot. It then visualizes the spatial distribution of correlation coefficients using a scatter plot.</p> <p>Parameters:</p> Name Type Description Default <code>adata</code> <code>AnnData</code> <p>An :class:<code>~anndata.AnnData</code> object containing the spatial transcriptomics data. - Original data should be in <code>adata.layers['original_st']</code>. - Reconstructed data should be in <code>adata.X</code>. - Spatial coordinates should be in <code>adata.obsm['spatial']</code>.</p> required <code>out_dir</code> <code>string</code> <p>The directory where the output plot (SVG format) will be saved.</p> required <code>project_name</code> <code>string, optional (default: 'test')</code> <p>The prefix to use for the saved SVG file.</p> <code>'test'</code> <code>rotation_angle</code> <code>float</code> <p>The angle to rotate the spatial coordinates, if any.</p> <code>None</code> <code>spot_size</code> <code>float, optional (default: 0.5)</code> <p>The size of the spots in the scatter plot.</p> <code>0.5</code> <p>Returns:</p> Type Description <code>None</code> <p>The function does not return any values but saves the generated scatter plot as an SVG file in the specified <code>out_dir</code>.</p> Source code in <code>cytobulk\\plots\\_plot.py</code> <pre><code>def plot_reconstruction(adata,\n                        out_dir,\n                        project_name=\"test\",\n                        rotation_angle=None,\n                        spot_size=0.5):\n    \"\"\"\n    Plot reconstructed spatial transcriptomics data with correlation analysis.\n\n    This function computes the Pearson correlation between the original and reconstructed spatial transcriptomics data for each spot. It then visualizes the spatial distribution of correlation coefficients using a scatter plot.\n\n    Parameters\n    ----------\n    adata : anndata.AnnData\n        An :class:`~anndata.AnnData` object containing the spatial transcriptomics data.\n        - Original data should be in `adata.layers['original_st']`.\n        - Reconstructed data should be in `adata.X`.\n        - Spatial coordinates should be in `adata.obsm['spatial']`.\n\n    out_dir : string\n        The directory where the output plot (SVG format) will be saved.\n\n    project_name : string, optional (default: 'test')\n        The prefix to use for the saved SVG file.\n\n    rotation_angle : float, optional\n        The angle to rotate the spatial coordinates, if any.\n\n    spot_size : float, optional (default: 0.5)\n        The size of the spots in the scatter plot.\n\n    Returns\n    -------\n    None\n        The function does not return any values but saves the generated scatter plot as an SVG file in the specified `out_dir`.\n    \"\"\"\n    from scipy.stats import pearsonr\n    adata.var_names_make_unique()\n    # Calculate Pearson correlation and p-value for each sample (row)\n    loc_xy=adata.obsm['spatial']\n    loc_xy=pd.DataFrame(loc_xy,columns=['x','y'],index=adata.obs_names)\n    if rotation_angle:\n        new_loc = loc_xy.apply(lambda x : utils.rotate_matrix(x['x'],x['y'],rotation_angle), axis=1)\n        loc_xy = pd.DataFrame(list(new_loc),columns=loc_xy.columns,index=loc_xy.index)\n\n    results = []\n    for i in range(adata.shape[0]):  # Loop through each sample\n        r, p = pearsonr(adata.layers['original_st'][i], adata.X[i])\n        results.append((i, r, p))  # Store index, Pearson r, and p-value\n\n    # Convert results to a DataFrame\n    results_df = pd.DataFrame(results, columns=['spot', 'Pearson R', 'pvalue'])\n    results_df.set_index('spot',inplace=True)\n    adata.obsm['spatial']=loc_xy.values\n    adata.obs = results_df\n    average_corr = round(np.mean(results_df['Pearson R']),3)\n\n    fig=sc.pl.spatial(\n        adata,\n        color='Pearson R',\n        img_key=None,\n        alpha=0.8,\n        color_map=\"mako_r\",\n        size=1.5,\n        title=f'Reconstructed ST\\nmean Pearson correlation = {average_corr}\\ngene number = {len(adata.var_names)}',\n        frameon=False,\n        spot_size=spot_size,\n        outline_width=0,\n        return_fig=True\n    )\n    plt.savefig(f\"{out_dir}/{project_name}_reconstructed_correlation.svg\", format=\"svg\", dpi=1200,bbox_inches = 'tight',transparent = True)\n</code></pre> <p><pre><code>df plot_gene_similarity(adata, \n                        marker_df, \n                        custom_palette=\"Spectral\")\n</code></pre> </p> <p>Compute and visualize cosine similarity for marker genes across cell types.</p> <p>This function calculates cosine similarity for marker genes between the gene expression matrix  and a mapping layer in an AnnData object. It generates a swarm plot to visualize the results  grouped by cell type.</p> <p>Parameters:</p> Name Type Description Default <code>adata</code> <code>AnnData</code> <p>An :class:<code>~anndata.AnnData</code> object containing gene expression data in <code>.X</code> and a mapping layer in <code>.layers[\"mapping_ori\"]</code>.</p> required <code>marker_df</code> <code>DataFrame</code> <p>DataFrame containing marker gene information. It must include the following columns: - 'gene_symbol': Gene symbol names. - 'cell_type': Cell type associated with the marker gene. - 'pvalue': P-value indicating marker significance. - 'score': Score representing the marker strength.</p> required <code>custom_palette</code> <code>str or list, optional (default: \"Spectral\")</code> <p>Custom color palette for plotting. Can be a string representing a seaborn palette or a list of colors.</p> <code>'Spectral'</code> <p>Returns:</p> Type Description <code>Figure</code> <p>A swarm plot showing cosine similarities for marker genes grouped by cell type.</p> Source code in <code>cytobulk\\plots\\_plot.py</code> <pre><code>def plot_gene_similarity(adata, marker_df, custom_palette=\"Spectral\"):\n    \"\"\"\n    Compute and visualize cosine similarity for marker genes across cell types.\n\n    This function calculates cosine similarity for marker genes between the gene expression matrix \n    and a mapping layer in an AnnData object. It generates a swarm plot to visualize the results \n    grouped by cell type.\n\n    Parameters\n    ----------\n    adata : anndata.AnnData\n        An :class:`~anndata.AnnData` object containing gene expression data in `.X` and a mapping layer in `.layers[\"mapping_ori\"]`.\n\n    marker_df : pandas.DataFrame\n        DataFrame containing marker gene information. It must include the following columns:\n        - 'gene_symbol': Gene symbol names.\n        - 'cell_type': Cell type associated with the marker gene.\n        - 'pvalue': P-value indicating marker significance.\n        - 'score': Score representing the marker strength.\n\n    custom_palette : str or list, optional (default: \"Spectral\")\n        Custom color palette for plotting. Can be a string representing a seaborn palette or a list of colors.\n\n    Returns\n    -------\n    matplotlib.pyplot.Figure\n        A swarm plot showing cosine similarities for marker genes grouped by cell type.\n    \"\"\"\n    # Access the gene expression matrix and mapping layer\n    import pandas as pd\n    import numpy as np\n    import scanpy as sc\n    from scipy.spatial.distance import cosine\n    import matplotlib.pyplot as plt\n    import seaborn as sns\n    mapping_ori = adata.layers[\"mapping_ori\"]  # Original mapping layer\n    adata_x = adata.X  # Main gene expression matrix\n\n    # Align gene symbols between the marker dataframe and the AnnData object\n    genes = adata.var.index.tolist()  # List of genes in AnnData\n    marker_genes = marker_df['gene_symbol'].tolist()  # List of marker genes\n    common_genes = list(set(marker_genes).intersection(genes))  # Find common genes\n\n    # Filter the marker DataFrame to only include the common genes\n    marker_df = marker_df[marker_df['gene_symbol'].isin(common_genes)]\n\n    # Initialize a list to store results for all cell types\n    all_results = []\n\n    # Group marker genes by cell type\n    for cell_type, group in marker_df.groupby(\"cell_type\"):\n        print(f\"Processing cell_type: {cell_type}\")\n\n        # Filter marker genes with p-value &lt; 0.05\n        filtered_group = group[group['pvalue'] &lt; 0.05]\n\n        # If more than 50 genes are available, select the top 50 based on the 'score' column\n        top_genes = filtered_group.nlargest(50, \"score\")\n\n        # Define a helper function to compute cosine similarity\n        def compute_cosine_similarity(gene_symbol, mapping_ori, adata_x, var_names):\n            \"\"\"\n            Compute cosine similarity for a given gene.\n\n            Parameters:\n            ----------\n            gene_symbol : str\n                The gene symbol to compute similarity for.\n            mapping_ori : np.ndarray\n                The original mapping layer array.\n            adata_x : np.ndarray\n                Gene expression matrix from AnnData.\n            var_names : list\n                List of gene names in AnnData.\n\n            Returns:\n            -------\n            float\n                Cosine similarity value or NaN if computation is not possible.\n            \"\"\"\n            # If the gene is not found in AnnData, return NaN\n            if gene_symbol not in var_names:\n                return np.nan\n\n            # Get the index of the gene in the AnnData object\n            gene_idx = var_names.index(gene_symbol)\n\n            # Extract expression vectors for the gene\n            gene_expression_vector = adata_x[:, gene_idx].flatten()  # Expression vector in adata.X\n            ori_vector = mapping_ori[:, gene_idx].flatten()  # Expression vector in mapping_ori\n\n            # Compute cosine similarity if vectors are non-zero\n            if np.any(gene_expression_vector) and np.any(ori_vector):\n                similarity = 1 - cosine(gene_expression_vector, ori_vector)\n            else:\n                similarity = np.nan  # Return NaN for zero vectors\n\n            return similarity\n\n        # Compute cosine similarity for each gene in the top genes\n        var_names = adata.var.index.tolist()  # Get gene names from AnnData\n        cosine_similarities = [\n            compute_cosine_similarity(gene_symbol, mapping_ori, adata.X, var_names)\n            for gene_symbol in top_genes[\"gene_symbol\"]\n        ]\n\n        # Add cosine similarity values to the DataFrame\n        top_genes[\"cosine_similarity\"] = cosine_similarities\n\n        # Append the results for the current cell type\n        all_results.append(top_genes)\n\n    # Concatenate results from all cell types into a single DataFrame\n    final_results = pd.concat(all_results, ignore_index=True)\n\n    # Use seaborn's default palette if no custom palette is provided\n  # Use seaborn's default color palette\n\n    # Create a Swarm Plot for cosine similarity grouped by cell type\n    plt.figure(figsize=(6, 4))  # Set the figure size to a smaller size (6x4 inches)\n    sns.swarmplot(\n        x=\"cell_type\", \n        y=\"cosine_similarity\", \n        data=final_results, \n        palette=custom_palette  # Use custom or default palette\n    )\n\n    # Add labels and customize the plot\n    plt.xlabel(\"Cell Type\", fontsize=12)\n    plt.ylabel(\"Cosine Similarity\", fontsize=12)\n    plt.xticks(fontsize=10)  # Adjust font size for x-axis labels\n    plt.tight_layout()  # Ensure the layout fits well\n\n    # Return the matplotlib.pyplot object for further customization or saving\n    return plt\n</code></pre> <p><pre><code>def plot_he_cell_type(data,out_dir)\n</code></pre> </p> <p>Visualize and save a scatter plot of cell locations by cell type.</p> <p>This function generates a scatter plot to visualize the spatial distribution of different cell types  based on their x and y coordinates. The plot is customized with specific colors for predefined cell types  and is saved as a PNG file.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>DataFrame</code> <p>A pandas DataFrame containing the following columns: - 'cell_type': Categorical data representing cell types (e.g., \"Epithelial Cells\"). - 'x': Numerical values representing the x-coordinates of the cells. - 'y': Numerical values representing the y-coordinates of the cells.</p> required <code>out_dir</code> <code>str</code> <p>The directory where the generated plot image will be saved. The plot will be saved as  \"cell_type.png\" within this directory.</p> required <p>Returns:</p> Type Description <code>None</code> <p>This function does not return any values. It generates and saves the scatter plot as a PNG file.</p> Notes <ul> <li>The plot uses predefined colors for the following cell types:<ul> <li>\"Epithelial Cells\": #A52A2A (brown)</li> <li>\"Neutrophils\": #0000B8 (blue)</li> <li>\"Plasma Cells\": #0D98BA (cyan)</li> <li>\"Connective Tissue\": #FFCC33 (yellow)</li> <li>\"Lymphocytes\": #B284BE (purple)   Cell types not listed above are assigned the color \"black\".</li> </ul> </li> <li>The y-axis is inverted to match the typical orientation of spatial data.</li> </ul> Source code in <code>cytobulk\\plots\\_plot.py</code> <pre><code>def plot_he_cell_type(data,out_dir):\n    \"\"\"\n    Visualize and save a scatter plot of cell locations by cell type.\n\n    This function generates a scatter plot to visualize the spatial distribution of different cell types \n    based on their x and y coordinates. The plot is customized with specific colors for predefined cell types \n    and is saved as a PNG file.\n\n    Parameters\n    ----------\n    data : pandas.DataFrame\n        A pandas DataFrame containing the following columns:\n        - 'cell_type': Categorical data representing cell types (e.g., \"Epithelial Cells\").\n        - 'x': Numerical values representing the x-coordinates of the cells.\n        - 'y': Numerical values representing the y-coordinates of the cells.\n\n    out_dir : str\n        The directory where the generated plot image will be saved. The plot will be saved as \n        \"cell_type.png\" within this directory.\n\n    Returns\n    -------\n    None\n        This function does not return any values. It generates and saves the scatter plot as a PNG file.\n\n    Notes\n    -----\n    - The plot uses predefined colors for the following cell types:\n        * \"Epithelial Cells\": #A52A2A (brown)\n        * \"Neutrophils\": #0000B8 (blue)\n        * \"Plasma Cells\": #0D98BA (cyan)\n        * \"Connective Tissue\": #FFCC33 (yellow)\n        * \"Lymphocytes\": #B284BE (purple)\n      Cell types not listed above are assigned the color \"black\".\n    - The y-axis is inverted to match the typical orientation of spatial data.\n    \"\"\"\n    import pandas as pd\n    import matplotlib.pyplot as plt\n\n    categories = data[\"cell_type\"].unique()\n    colors = {\n        \"Epithelial Cells\": \"#A52A2A\",  \n        \"Neutrophils\": \"#0000B8\",      \n        \"Plasma Cells\": \"#0D98BA\",     \n        \"Connective Tissue\": \"#FFCC33\", \n        \"Lymphocytes\": \"#B284BE\"      \n    }\n\n    plt.figure(figsize=(4, 4))\n\n    for category in categories:\n        subset = data[data[\"cell_type\"] == category]\n        plt.scatter(subset[\"x\"], subset[\"y\"], label=category, color=colors.get(category, \"black\"), s=10, alpha=0.8)\n    plt.legend(\n        loc=\"upper right\",             # Place the legend in the top-right corner\n        title=\"Cell Types\",            # Add a title to the legend\n        fontsize=8,                    # Set font size for the legend labels\n        title_fontsize=10,             # Set font size for the legend title\n        markerscale=1.5                # Scale the legend markers (scatter points)\n    )\n\n\n    plt.gca().axis(\"off\")\n    plt.gca().invert_yaxis()\n    save_path = f\"{out_dir}/cell_type.png\"\n    plt.tight_layout()\n    plt.savefig(save_path, dpi=300, bbox_inches=\"tight\", pad_inches=0) \n    plt.show()\n</code></pre>"},{"location":"tools/","title":"tools","text":"<ul> <li>_mapping</li> <li>_deconv</li> </ul>"},{"location":"tools/_deconv/","title":"tools._deconv","text":"<p><pre><code>def bulk_deconv(bulk_data,\n                sc_adata,\n                annotation_key,\n                marker_data=None,\n                rename=None,\n                dataset_name=\"\",\n                out_dir='.',\n                different_source=True,\n                cell_list=None,\n                scale_factors=10000,\n                trans_method=\"log\",\n                save = True,\n                save_figure=True,\n                n_cell=100,\n                **kwargs)\n</code></pre> </p> <p>Deconvolute the cell type fraction from bulk expression data with single cell dataset as reference. Reconstruct the bulk data using single cell.</p> <p>Parameters:</p> Name Type Description Default <code>bulk_data</code> <code>dataframe</code> <p>An :class:<code>~pandas.dataframe</code> containing the bulk expression data.  The first column should be gene symbol, following column should be sample name.</p> required <code>sc_adata</code> <code>AnnData</code> <p>An :class:<code>~anndata.AnnData</code> containing the single cell expression.</p> required <code>annotation_key</code> <code>string</code> <p>The <code>.obs</code> key where the single cell annotation is stored. : anndata.AnnData.</p> required <code>marker_data</code> <p>An :class:<code>~pandas.dataframe</code> which columns are cell types, rows are marker gene.</p> required <code>dataset_name</code> <code>string.</code> <p>The prefix of output file.</p> <code>''</code> <code>out_dir</code> <code>string</code> <p>The path to store the output data.</p> <code>'.'</code> <code>different_source</code> <code>boolean</code> <p>True for single cell and bulk data from the same sample, which means not executing batch effect. False for single cell and bulk data from the different samples, which means executing batch effect.</p> <code>True</code> <code>cell_list</code> <code>list</code> <p>The list indicate the cell type names which need to take into consideration.</p> <code>None</code> <code>scale_factors</code> <code>int</code> <p>The number of counts to normalize every observation to before computing profiles. If <code>None</code>, no normalization is performed.</p> <code>100000</code> <code>trans_method</code> <code>string</code> <p>What transformation to apply to the expression before computing the profiles.  - \"log\" : log(x+1) - <code>None</code> : no transformation</p> <code>'log'</code> <code>save</code> <code>boolean</code> <p>Whether save the result data during each step. If saving, the processing may be skipped.</p> <code>True</code> <code>save_figure</code> <code>boolean</code> <p>Whether save figures during preprocessing. eg. scatter plot of pca data.</p> <code>True</code> <code>mapping_sc</code> <code>boolean</code> <p>Whether reconstruct the bulk data with single cell data.</p> required <code>n_cell</code> <code>int</code> <p>The number of cells within each bulk.</p> <code>2000</code> <code>**kwargs</code> <p>Additional keyword arguments forwarded to :func:<code>~cytobulk.preprocessing.qc_bulk_sc</code>.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Returns the deconvolution result and reconstructed bulk.</code> Source code in <code>cytobulk\\tools\\_deconv.py</code> <pre><code>def bulk_deconv(bulk_data,\n                sc_adata,\n                annotation_key,\n                marker_list=None,\n                rename=None,\n                dataset_name=\"\",\n                out_dir='.',\n                different_source=True,\n                cell_list=None,\n                scale_factors=100000,\n                trans_method=\"log\",\n                save = True,\n                save_figure=True,\n                n_cell=2000,\n                **kwargs):\n    \"\"\"\n    Deconvolute the cell type fraction from bulk expression data with single cell dataset as reference.\n    Reconstruct the bulk data using single cell.\n\n    Parameters\n    ----------\n    bulk_data : dataframe\n        An :class:`~pandas.dataframe` containing the bulk expression data. \n        The first column should be gene symbol, following column should be sample name.\n    sc_adata : anndata.AnnData\n        An :class:`~anndata.AnnData` containing the single cell expression.\n    annotation_key : string\n        The `.obs` key where the single cell annotation is stored. : anndata.AnnData.\n    marker_data : \n        An :class:`~pandas.dataframe` which columns are cell types, rows are marker gene.\n    dataset_name : string.\n        The prefix of output file.\n    out_dir : string, optional\n        The path to store the output data.\n    different_source : boolean, optional\n        True for single cell and bulk data from the same sample, which means not executing batch effect.\n        False for single cell and bulk data from the different samples, which means executing batch effect.\n    cell_list : list, optional\n        The list indicate the cell type names which need to take into consideration.\n    scale_factors : int, optional\n        The number of counts to normalize every observation to before computing profiles. If `None`, no normalization is performed. \n    trans_method : string, optional\n        What transformation to apply to the expression before computing the profiles. \n        - \"log\" : log(x+1)\n        - `None` : no transformation\n    save : boolean, optional\n        Whether save the result data during each step. If saving, the processing may be skipped.\n    save_figure : boolean, optional\n        Whether save figures during preprocessing. eg. scatter plot of pca data.\n    mapping_sc : boolean, optional\n        Whether reconstruct the bulk data with single cell data.\n    n_cell : int, optional\n        The number of cells within each bulk.\n    **kwargs : \n        Additional keyword arguments forwarded to\n        :func:`~cytobulk.preprocessing.qc_bulk_sc`.\n\n\n    Returns\n    -------\n    Returns the deconvolution result and reconstructed bulk.\n    \"\"\"\n    # check the filtered dataset. If exist, skipping preprocessing.\n    bulk_ori_adata = bulk_data.copy()\n    if exists(f'{out_dir}/filtered/pseudo_bulk_{dataset_name}.h5ad') and exists(f'{out_dir}/filtered/sc_data_{dataset_name}.h5ad') and \\\n    exists(f'{out_dir}/filtered/bulk_data_{dataset_name}.h5ad') and exists(f'{out_dir}/filtered/cells_{dataset_name}.json'):\n\n        pseudo_bulk = sc.read_h5ad(f\"{out_dir}/filtered/pseudo_bulk_{dataset_name}.h5ad\")\n        sc_adata = sc.read_h5ad(f\"{out_dir}/filtered/sc_data_{dataset_name}.h5ad\")\n        bulk_adata = sc.read_h5ad(f\"{out_dir}/filtered/bulk_data_{dataset_name}.h5ad\")\n        with open(f\"{out_dir}/filtered/cells_{dataset_name}.json\") as json_file:\n            common_cell = json.load(json_file)\n        annotation_key=\"curated_cell_type\"\n    else:\n        #preprocessing\n        sc_adata, pseudo_bulk, bulk_adata, common_cell,annotation_key = pp.preprocessing(bulk_data,\n                                                                        sc_adata,\n                                                                        annotation_key,\n                                                                        is_st=False,\n                                                                        marker_list=marker_list,\n                                                                        rename=rename,\n                                                                        dataset_name=dataset_name,\n                                                                        out_dir=out_dir,\n                                                                        different_source=different_source,\n                                                                        cell_list=cell_list,\n                                                                        scale_factors=scale_factors,\n                                                                        trans_method=trans_method,\n                                                                        n_sample_each_group=len(bulk_data.obs_names)*5,\n                                                                        min_cells_each_group=n_cell,\n                                                                        cell_gap_each_group=50,\n                                                                        group_number=10,\n                                                                        save = save,\n                                                                        save_figure=save_figure,\n                                                                        **kwargs)\n    #deconvolution\n    if exists(f'{out_dir}/output/{dataset_name}_prediction_frac.csv'):\n        deconv_result = pd.read_csv(f'{out_dir}/output/{dataset_name}_prediction_frac.csv',index_col=0)\n    else:\n        deconv_result = _bulk_sc_deconv(bulk_adata, \n                                        pseudo_bulk, \n                                        sc_adata, \n                                        common_cell,\n                                        annotation_key = annotation_key, \n                                        dataset_name=dataset_name, \n                                        out_dir=out_dir)\n    row_sums = deconv_result.sum(axis=1)\n    df_normalized = deconv_result.div(row_sums, axis=0)\n    bulk_ori_adata.uns['deconv']=df_normalized\n    df_normalized.to_csv(f\"{out_dir}/output/{dataset_name}_prediction_frac_normalized.csv\")\n    bulk_ori_adata.write_h5ad(f'{out_dir}/output/{dataset_name}_bulk_adata.h5ad')\n\n    return deconv_result,bulk_ori_adata\n</code></pre> <p><pre><code>st_deconv(st_adata,\n            sc_adata,\n            annotation_key,\n            marker_list=None,\n            rename=None,\n            dataset_name=\"\",\n            out_dir='.',\n            different_source=True,\n            cell_list=None,\n            scale_factors=10000,\n            trans_method=\"log\",\n            save = True,\n            save_figure=True,\n            n_cell=10,\n            **kwargs)\n</code></pre> </p> <p>Deconvolute the cell type fraction from spot expression data with single cell dataset as reference.</p> <p>Parameters:</p> Name Type Description Default <code>st_adata</code> <code>AnnData</code> <p>An :class:<code>~anndata.AnnData</code> containing the single cell expression. The first column should be gene symbol, following column should be spot name.</p> required <code>sc_adata</code> <code>AnnData</code> <p>An :class:<code>~anndata.AnnData</code> containing the single cell expression.</p> required <code>annotation_key</code> <code>string</code> <p>The <code>.obs</code> key where the single cell annotation is stored. : anndata.AnnData.</p> required <code>marker_list</code> <p>An :class:<code>~pandas.dataframe</code> which columns are cell types, rows are marker gene.</p> <code>None</code> <code>dataset_name</code> <code>string.</code> <p>The prefix of output file.</p> <code>''</code> <code>out_dir</code> <code>string</code> <p>The path to store the output data.</p> <code>'.'</code> <code>different_source</code> <code>boolean</code> <p>True for single cell and bulk data from the same sample, which means not executing batch effect. False for single cell and bulk data from the different samples, which means executing batch effect.</p> <code>True</code> <code>cell_list</code> <code>list</code> <p>The list indicate the cell type names which need to take into consideration.</p> <code>None</code> <code>scale_factors</code> <code>int</code> <p>The number of counts to normalize every observation to before computing profiles. If <code>None</code>, no normalization is performed.</p> <code>10000</code> <code>trans_method</code> <code>string</code> <p>What transformation to apply to the expression before computing the profiles.  - \"log\" : log(x+1) - <code>None</code> : no transformation</p> <code>'log'</code> <code>save</code> <code>boolean</code> <p>Whether save the result data during each step. If saving, the processing may be skipped.</p> <code>True</code> <code>save_figure</code> <code>boolean</code> <p>Whether save figures during preprocessing. eg. scatter plot of pca data.</p> <code>True</code> <code>n_cell</code> <code>int</code> <p>The number of cells within each bulk.</p> <code>10</code> <code>**kwargs</code> <p>Additional keyword arguments forwarded to :func:<code>~cytobulk.preprocessing.qc_bulk_sc</code>.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Returns the deconvolution result and reconstructed st.</code> Source code in <code>cytobulk\\tools\\_deconv.py</code> <pre><code>def st_deconv(st_adata,\n            sc_adata,\n            annotation_key,\n            marker_list=None,\n            rename=None,\n            dataset_name=\"\",\n            out_dir='.',\n            different_source=True,\n            cell_list=None,\n            scale_factors=10000,\n            trans_method=\"log\",\n            save = True,\n            save_figure=True,\n            n_cell=10,\n            max_cells=40,\n            **kwargs):\n    \"\"\"\n    Deconvolute the cell type fraction from spot expression data with single cell dataset as reference.\n\n    Parameters\n    ----------\n    st_adata : anndata.AnnData\n        An :class:`~anndata.AnnData` containing the single cell expression.\n        The first column should be gene symbol, following column should be spot name.\n    sc_adata : anndata.AnnData\n        An :class:`~anndata.AnnData` containing the single cell expression.\n    annotation_key : string\n        The `.obs` key where the single cell annotation is stored. : anndata.AnnData.\n    marker_list : \n        An :class:`~pandas.dataframe` which columns are cell types, rows are marker gene.\n    dataset_name : string.\n        The prefix of output file.\n    out_dir : string, optional\n        The path to store the output data.\n    different_source : boolean, optional\n        True for single cell and bulk data from the same sample, which means not executing batch effect.\n        False for single cell and bulk data from the different samples, which means executing batch effect.\n    cell_list : list, optional\n        The list indicate the cell type names which need to take into consideration.\n    scale_factors : int, optional\n        The number of counts to normalize every observation to before computing profiles. If `None`, no normalization is performed. \n    trans_method : string, optional\n        What transformation to apply to the expression before computing the profiles. \n        - \"log\" : log(x+1)\n        - `None` : no transformation\n    save : boolean, optional\n        Whether save the result data during each step. If saving, the processing may be skipped.\n    save_figure : boolean, optional\n        Whether save figures during preprocessing. eg. scatter plot of pca data.\n    n_cell : int, optional\n        The number of cells within each bulk.\n    **kwargs : \n        Additional keyword arguments forwarded to\n        :func:`~cytobulk.preprocessing.qc_bulk_sc`.\n\n\n    Returns\n    -------\n    Returns the deconvolution result and reconstructed st.\n    \"\"\"\n    # check the filtered dataset. If exist, skipping preprocessing.\n    st_ori_adata = st_adata.copy()\n    if exists(f'{out_dir}/filtered/pseudo_bulk_{dataset_name}.h5ad') and exists(f'{out_dir}/filtered/sc_data_{dataset_name}.h5ad') and \\\n    exists(f'{out_dir}/filtered/bulk_data_{dataset_name}.h5ad') and exists(f'{out_dir}/filtered/cells_{dataset_name}.json'):\n        pseudo_st = sc.read_h5ad(f\"{out_dir}/filtered/pseudo_bulk_{dataset_name}.h5ad\")\n        sc_adata = sc.read_h5ad(f\"{out_dir}/filtered/sc_data_{dataset_name}.h5ad\")\n        st_adata = sc.read_h5ad(f\"{out_dir}/filtered/bulk_data_{dataset_name}.h5ad\")\n        with open(f\"{out_dir}/filtered/cells_{dataset_name}.json\") as json_file:\n            common_cell = json.load(json_file)\n        annotation_key=\"curated_cell_type\"\n    else:\n        #preprocessing\n        sc_adata, pseudo_st, st_adata,common_cell,annotation_key = pp.preprocessing(st_adata,\n                                                                        sc_adata,\n                                                                        annotation_key,\n                                                                        is_st=True,\n                                                                        marker_list=marker_list,\n                                                                        rename=rename,\n                                                                        dataset_name=dataset_name,\n                                                                        out_dir=out_dir,\n                                                                        different_source=different_source,\n                                                                        cell_list=cell_list,\n                                                                        scale_factors=scale_factors,\n                                                                        trans_method=trans_method,\n                                                                        n_sample_each_group=len(st_adata.obs_names)*6,\n                                                                        min_cells_each_group=n_cell,\n                                                                        cell_gap_each_group=1,\n                                                                        group_number=5,\n                                                                        save = save,\n                                                                        save_figure=save_figure,\n                                                                        **kwargs)\n    #deconvolution\n    if exists(f'{out_dir}/output/{dataset_name}_prediction_frac.csv'):\n        deconv_result = pd.read_csv(f'{out_dir}/output/{dataset_name}_prediction_frac.csv',index_col=0)\n    else:\n        deconv_result = _bulk_sc_deconv(st_adata, \n                                        pseudo_st, \n                                        sc_adata, \n                                        common_cell,\n                                        annotation_key = annotation_key, \n                                        dataset_name=dataset_name, \n                                        out_dir=out_dir,\n                                        batch_effect=different_source,\n                                        is_st=True)\n    threshold = 1 / max_cells\n    deconv_result[deconv_result &lt; threshold] = 0\n    row_sums = deconv_result.sum(axis=1)\n    df_normalized = deconv_result.div(row_sums, axis=0)\n    st_ori_adata.uns['deconv']=df_normalized\n    df_normalized.to_csv(f\"{out_dir}/output/{dataset_name}_prediction_frac_normalized.csv\")\n    st_ori_adata.write_h5ad(f'{out_dir}/output/{dataset_name}_st_adata.h5ad')\n    return df_normalized,st_ori_adata\n</code></pre>"},{"location":"tools/_graph_deconv/","title":"graph deconv","text":""},{"location":"tools/_graph_deconv/#cytobulk.tools.model._graph_deconv.Const","title":"<code>Const</code>","text":"<p>Some constants used in the class.</p> Source code in <code>cytobulk\\tools\\model\\_graph_deconv.py</code> <pre><code>class Const:\n    \"\"\"\n    Some constants used in the class.\n    \"\"\"\n    MODE_TRAINING = \"training\"\n    MODE_PREDICTION = \"prediction\"\n    SAMPLE_COL = \"sample_name\"\n    GENE_SYMBOL_COL = \"GeneSymbol\"\n    BATCH_SIZE = 64\n    LEARNING_RATE = 0.005\n    MAX_SPLIT = 10\n    EPOCH_NUM_BULK = 12\n    EPOCH_NUM_ST = 10\n    SEED = 20230602\n    CHEB_MODE = 0\n    MAX_RETRY=1\n</code></pre>"},{"location":"tools/_graph_deconv/#cytobulk.tools.model._graph_deconv.GraphDeconv","title":"<code>GraphDeconv</code>","text":"Source code in <code>cytobulk\\tools\\model\\_graph_deconv.py</code> <pre><code>class GraphDeconv:\n    def __init__(\n            self,\n            cell_num=200,\n            mode=Const.MODE_PREDICTION,\n            use_gpu=True\n    ):\n        \"\"\"\n            cell_num: int, the number of cell for each bulk sample.\n            mode: string, prediction or training.\n            use_gpu: bool, if `True`, the model will use CUDA or MPS, otherwise, it will only use CPU.\n        \"\"\"\n        self.cell_num = cell_num\n        self.mode = mode\n        self.device = configure_device(use_gpu)\n\n    def fit(\n        self,\n        expression,\n        cell_list=None,\n        sc_adata=None,\n        annotation_key = None,\n        model_folder=None,\n        out_dir='./',\n        file_dir = \"./\",\n        project='',\n        save=True,\n        is_st=False):\n\n        utils.check_paths(output_folder=out_dir)\n        device=self.device\n        tot_cell_list = cell_list\n        final_ret = pd.DataFrame()\n        for cell in tqdm(tot_cell_list, leave=False):\n            mat_G, num = get_G(cell, sc_adata,annotation_key)\n            mat_G = mat_G.to(device)\n            #input_bulk = expression[sel_gene]\n            input_bulk = pd.read_csv(f\"{file_dir}/batch_effect/{project}_batch_effected.txt\",sep='\\t',index_col=0)[expression.obs_names.tolist()]\n\n            input_bulk.clip(lower=0,inplace=True)\n            #input_bulk = input_bulk.T\n            #test_data = input_bulk[sel_gene].values\n            test_data = input_bulk.T.values\n\n\n            test_dataset = InferDataset(torch.FloatTensor(test_data))\n            test_loader = torch.utils.data.DataLoader(dataset = test_dataset, batch_size = 1, shuffle = False)\n\n            if not is_st:\n                model_graph = GraphNet_bulk(num,num,num,2, device=device).to(device)\n            else:\n                model_graph = GraphNet_st(num,num,num,2, device=device).to(device)\n\n            model_graph.load_state_dict(torch.load(f'{model_folder}/graph_{cell}.pt'))\n            model_linear = LinearModel(num).to(self.device)\n            model_linear.load_state_dict(torch.load(f'{model_folder}/linear_{cell}.pt'))\n            model_graph.eval(); model_linear.eval()\n            merged_ret = pd.DataFrame()\n            for _, data in enumerate(test_loader):            \n                data = data.to(torch.float32).to(self.device)\n\n                zlist=torch.reshape(model_graph(mat_G, data), (1, -1))      \n                output_frac = model_linear(zlist)\n\n                partial_ret = (output_frac.cpu().detach().clone().numpy()).reshape((-1, 1))\n                partial_ret = pd.DataFrame(partial_ret)\n                merged_ret = pd.concat([merged_ret, partial_ret])\n\n            final_ret = pd.concat([final_ret, merged_ret], axis=1)\n        final_ret = pd.DataFrame(final_ret.values,index=expression.obs_names,columns=tot_cell_list)\n        # for debuging\n        if save:\n            final_ret.to_csv(f\"{out_dir}/{project}_prediction_frac.csv\")\n        return final_ret\n\n    def train(\n        self,\n        presudo_bulk=None,\n        bulk_adata=None,\n        cell_list=None,\n        sc_adata=None,\n        annotation_key = None,\n        batch_size = Const.BATCH_SIZE,\n        out_dir = \"./\",\n        project_name=\"\",\n        data_num=10000,\n        batch_effect=True,\n        is_st=False\n    ):\n        \"\"\"\n        out_dir: string, the directory for saving trained models.\n        expression: string, needed if `mode` is `training`, the path of the bulk expression file.\n        fraction: string, needed if `mode` is `training`, the path of the bulk fraction file.\n        marker: string, needed if `mode` is `training`, the path of the gene marker file.\n        sc_folder: string, needed if `mode` is `training`, the path of the folder containing single cell reference.\n        \"\"\"\n\n        # checking\n        if self.mode != Const.MODE_TRAINING:\n            raise ValueError(\"This function can only be used under training mode.\")\n\n        utils.check_paths(output_folder=out_dir)\n        utils.check_paths(output_folder=out_dir+\"/plot\")\n\n        '''\n        if expression.shape[0] != fraction.shape[0]:\n            raise ValueError(f\"Please check the input, the shape of the expression file {expression.shape} \\\n                            does not match the one of fraction {fraction.shape}.\")\n        '''\n        tot_cell_list = cell_list\n        presudo_bulk_full = presudo_bulk.copy()\n        bulk_adata_full = bulk_adata.copy()\n        presudo_bulk_full, bulk_adata_full = preprocessing.remove_batch_effect(presudo_bulk_full, bulk_adata_full, out_dir=out_dir, project=project_name,batch_effect=batch_effect)\n\n        if batch_effect:\n            loc=\"batch_effected\"\n            plots.batch_effect(bulk_adata_full, presudo_bulk_full,out_dir=out_dir+\"/plot\",title=project_name)\n        else:\n            loc=None\n\n        sample_list = utils.filter_samples(presudo_bulk_full, bulk_adata_full,data_num=data_num,loc=loc)\n\n        presudo_bulk_train = presudo_bulk_full[sample_list,:]\n\n        expression = get.count_data_t(presudo_bulk_train,counts_location=loc)\n        #reference = get.count_data_t(bulk_adata_full,counts_location=loc)\n        fraction = get.meta(presudo_bulk_train,position_key=\"obs\")\n        if torch.backends.mps.is_available():\n            for cell in tot_cell_list:\n                train_cell_loop_once(cell, expression, fraction,bulk_adata_full, batch_size, sc_adata, out_dir, self.device,annotation_key,project_name,data_num,loc,is_st)\n        else:\n            for cell in tot_cell_list:\n                train_cell_loop_once(cell, expression, fraction, bulk_adata_full, batch_size, sc_adata, out_dir, self.device,annotation_key,project_name,data_num,loc,is_st)\n</code></pre>"},{"location":"tools/_graph_deconv/#cytobulk.tools.model._graph_deconv.GraphDeconv.__init__","title":"<code>__init__(cell_num=200, mode=Const.MODE_PREDICTION, use_gpu=True)</code>","text":"<p>cell_num: int, the number of cell for each bulk sample. mode: string, prediction or training. use_gpu: bool, if <code>True</code>, the model will use CUDA or MPS, otherwise, it will only use CPU.</p> Source code in <code>cytobulk\\tools\\model\\_graph_deconv.py</code> <pre><code>def __init__(\n        self,\n        cell_num=200,\n        mode=Const.MODE_PREDICTION,\n        use_gpu=True\n):\n    \"\"\"\n        cell_num: int, the number of cell for each bulk sample.\n        mode: string, prediction or training.\n        use_gpu: bool, if `True`, the model will use CUDA or MPS, otherwise, it will only use CPU.\n    \"\"\"\n    self.cell_num = cell_num\n    self.mode = mode\n    self.device = configure_device(use_gpu)\n</code></pre>"},{"location":"tools/_graph_deconv/#cytobulk.tools.model._graph_deconv.GraphDeconv.train","title":"<code>train(presudo_bulk=None, bulk_adata=None, cell_list=None, sc_adata=None, annotation_key=None, batch_size=Const.BATCH_SIZE, out_dir='./', project_name='', data_num=10000, batch_effect=True, is_st=False)</code>","text":"<p>out_dir: string, the directory for saving trained models. expression: string, needed if <code>mode</code> is <code>training</code>, the path of the bulk expression file. fraction: string, needed if <code>mode</code> is <code>training</code>, the path of the bulk fraction file. marker: string, needed if <code>mode</code> is <code>training</code>, the path of the gene marker file. sc_folder: string, needed if <code>mode</code> is <code>training</code>, the path of the folder containing single cell reference.</p> Source code in <code>cytobulk\\tools\\model\\_graph_deconv.py</code> <pre><code>def train(\n    self,\n    presudo_bulk=None,\n    bulk_adata=None,\n    cell_list=None,\n    sc_adata=None,\n    annotation_key = None,\n    batch_size = Const.BATCH_SIZE,\n    out_dir = \"./\",\n    project_name=\"\",\n    data_num=10000,\n    batch_effect=True,\n    is_st=False\n):\n    \"\"\"\n    out_dir: string, the directory for saving trained models.\n    expression: string, needed if `mode` is `training`, the path of the bulk expression file.\n    fraction: string, needed if `mode` is `training`, the path of the bulk fraction file.\n    marker: string, needed if `mode` is `training`, the path of the gene marker file.\n    sc_folder: string, needed if `mode` is `training`, the path of the folder containing single cell reference.\n    \"\"\"\n\n    # checking\n    if self.mode != Const.MODE_TRAINING:\n        raise ValueError(\"This function can only be used under training mode.\")\n\n    utils.check_paths(output_folder=out_dir)\n    utils.check_paths(output_folder=out_dir+\"/plot\")\n\n    '''\n    if expression.shape[0] != fraction.shape[0]:\n        raise ValueError(f\"Please check the input, the shape of the expression file {expression.shape} \\\n                        does not match the one of fraction {fraction.shape}.\")\n    '''\n    tot_cell_list = cell_list\n    presudo_bulk_full = presudo_bulk.copy()\n    bulk_adata_full = bulk_adata.copy()\n    presudo_bulk_full, bulk_adata_full = preprocessing.remove_batch_effect(presudo_bulk_full, bulk_adata_full, out_dir=out_dir, project=project_name,batch_effect=batch_effect)\n\n    if batch_effect:\n        loc=\"batch_effected\"\n        plots.batch_effect(bulk_adata_full, presudo_bulk_full,out_dir=out_dir+\"/plot\",title=project_name)\n    else:\n        loc=None\n\n    sample_list = utils.filter_samples(presudo_bulk_full, bulk_adata_full,data_num=data_num,loc=loc)\n\n    presudo_bulk_train = presudo_bulk_full[sample_list,:]\n\n    expression = get.count_data_t(presudo_bulk_train,counts_location=loc)\n    #reference = get.count_data_t(bulk_adata_full,counts_location=loc)\n    fraction = get.meta(presudo_bulk_train,position_key=\"obs\")\n    if torch.backends.mps.is_available():\n        for cell in tot_cell_list:\n            train_cell_loop_once(cell, expression, fraction,bulk_adata_full, batch_size, sc_adata, out_dir, self.device,annotation_key,project_name,data_num,loc,is_st)\n    else:\n        for cell in tot_cell_list:\n            train_cell_loop_once(cell, expression, fraction, bulk_adata_full, batch_size, sc_adata, out_dir, self.device,annotation_key,project_name,data_num,loc,is_st)\n</code></pre>"},{"location":"tools/_mapping/","title":"tools._mapping","text":"<p><pre><code>def bulk_mapping(frac_data,\n                bulk_adata,\n                sc_adata,\n                n_cell=100,\n                annotation_key=\"curated_cell_type\",\n                bulk_layer=None,\n                sc_layer=None,\n                reorder=True,\n                multiprocessing=True,\n                cpu_num=cpu_count()-2,\n                dataset_name=\"\",\n                out_dir=\".\",\n                normalization=True,\n                filter_gene=True,\n                cut_off_value=0.6,\n                save=True)\n</code></pre> </p> <p>Reconstruct bulk data using single-cell data and cell type fractions.</p> <p>This function maps bulk expression data to single-cell expression data using cell type fraction information and various preprocessing steps.</p> <p>Parameters:</p> Name Type Description Default <code>bulk_adata</code> <code>AnnData</code> <p>An :class:<code>~anndata.AnnData</code> object containing the input bulk data.</p> required <code>sc_adata</code> <code>AnnData</code> <p>An :class:<code>~anndata.AnnData</code> object containing the single-cell expression data.</p> required <code>n_cell</code> <code>int</code> <p>Number of cells per bulk sample.</p> <code>100</code> <code>annotation_key</code> <code>string</code> <p>Key in <code>sc_adata.obs</code> for single-cell annotations.</p> <code>'curated_cell_type'</code> <code>bulk_layer</code> <code>string</code> <p>Layer in <code>bulk_adata</code> to use for bulk expression data.</p> <code>None</code> <code>sc_layer</code> <code>string</code> <p>Layer in <code>sc_adata</code> to use for single-cell expression data.</p> <code>None</code> <code>reorder</code> <code>bool, optional (default: True)</code> <p>Whether to reorder genes to ensure consistency between bulk and single-cell data.</p> <code>True</code> <code>multiprocessing</code> <code>bool, optional (default: True)</code> <p>Whether to use multiprocessing for efficiency.</p> <code>True</code> <code>cpu_num</code> <code>int</code> <p>Number of CPUs to use if multiprocessing is enabled.</p> <code>cpu_count() - 4</code> <code>project</code> <code>string</code> <p>Prefix for output files.</p> <code>''</code> <code>out_dir</code> <code>string</code> <p>Directory to store output files.</p> <code>'.'</code> <code>normalization</code> <code>bool, optional (default: True)</code> <p>Whether to apply CPM normalization to data.</p> <code>True</code> <code>filter_gene</code> <code>bool, optional (default: True)</code> <p>Whether to filter genes based on cosine similarity.</p> <code>True</code> <code>cut_off_value</code> <code>float, optional (default: 0.6)</code> <p>Threshold for cosine similarity when filtering genes.</p> required <code>save</code> <code>bool, optional (default: True)</code> <p>Whether to save the result files.</p> <code>True</code> <p>Returns:</p> Name Type Description <code>bulk_adata</code> <code>AnnData</code> <p>The processed bulk data with mapping results.</p> <code>df</code> <code>DataFrame</code> <p>DataFrame containing the mapping of bulk samples to single-cell IDs.</p> Source code in <code>cytobulk\\tools\\_mapping.py</code> <pre><code>def bulk_mapping(bulk_adata,\n                sc_adata,\n                n_cell=100,\n                annotation_key=\"curated_cell_type\",\n                bulk_layer=None,\n                sc_layer=None,\n                reorder=True,\n                multiprocessing=True,\n                cpu_num=cpu_count()-4,\n                project=\"\",\n                out_dir=\".\",\n                normalization=True,\n                filter_gene=True,\n                save=True):\n    \"\"\"\n    Reconstruct bulk data using single-cell data and cell type fractions.\n\n    This function maps bulk expression data to single-cell expression data using\n    cell type fraction information and various preprocessing steps.\n\n    Parameters\n    ----------\n    bulk_adata : anndata.AnnData\n        An :class:`~anndata.AnnData` object containing the input bulk data.\n\n    sc_adata : anndata.AnnData\n        An :class:`~anndata.AnnData` object containing the single-cell expression data.\n\n    n_cell : int, optional\n        Number of cells per bulk sample.\n\n    annotation_key : string, optional\n        Key in `sc_adata.obs` for single-cell annotations.\n\n    bulk_layer : string, optional\n        Layer in `bulk_adata` to use for bulk expression data.\n\n    sc_layer : string, optional\n        Layer in `sc_adata` to use for single-cell expression data.\n\n    reorder : bool, optional (default: True)\n        Whether to reorder genes to ensure consistency between bulk and single-cell data.\n\n    multiprocessing : bool, optional (default: True)\n        Whether to use multiprocessing for efficiency.\n\n    cpu_num : int, optional\n        Number of CPUs to use if multiprocessing is enabled.\n\n    project : string, optional\n        Prefix for output files.\n\n    out_dir : string, optional\n        Directory to store output files.\n\n    normalization : bool, optional (default: True)\n        Whether to apply CPM normalization to data.\n\n    filter_gene : bool, optional (default: True)\n        Whether to filter genes based on cosine similarity.\n\n    cut_off_value : float, optional (default: 0.6)\n        Threshold for cosine similarity when filtering genes.\n\n    save : bool, optional (default: True)\n        Whether to save the result files.\n\n    Returns\n    -------\n    bulk_adata : anndata.AnnData\n        The processed bulk data with mapping results.\n\n    df : pandas.DataFrame\n        DataFrame containing the mapping of bulk samples to single-cell IDs.\n    \"\"\"\n\n    start_t = time.perf_counter()\n    print(\"=================================================================================================\")\n    print('Start to mapping bulk data with single cell dataset.')\n    # format data\n    bulk_adata.var_names_make_unique()\n    sc_adata.var_names_make_unique()\n    intersect_gene = bulk_adata.var_names.intersection(sc_adata.var_names)\n    bulk_adata = bulk_adata[:,intersect_gene]\n    sc_adata = sc_adata[:,intersect_gene]\n    cell_prop = bulk_adata.uns['deconv']\n    cell_matrix = np.floor(n_cell * cell_prop)\n    cell_num = cell_matrix.astype(int)\n    meta_data = sc_adata.obs[[annotation_key]]\n    meta_dict = meta_data.groupby(meta_data[annotation_key]).groups\n    for key, value in meta_dict.items():\n        meta_dict[key] = np.array(value)\n    cellname_list=cell_prop.columns\n    cell_list = np.array(sc_adata.obs_names)\n    #normalization\n    bulk_adata.layers['mapping_ori'] = bulk_adata.X.copy()\n    if normalization:\n        sc_adata=utils.normalization_cpm(sc_adata,scale_factors=100000,trans_method=\"log\")\n        bulk_adata=utils.normalization_cpm(bulk_adata,scale_factors=100000,trans_method=\"log\")\n    bulk_adata.layers['mapping_nor'] = bulk_adata.X.copy()\n    input_sc_data = get.count_data(sc_adata,counts_location=sc_layer)\n    bulk_data = get.count_data(bulk_adata,counts_location=bulk_layer)\n\n    if reorder:\n        intersect_gene = input_sc_data.index.intersection(bulk_data.index)\n        input_sc_data = input_sc_data.loc[intersect_gene,:]\n        bulk_data = bulk_data.loc[intersect_gene,:]\n\n    sc_data = utils.normal_center(input_sc_data)\n    bulk_data = utils.normal_center(bulk_data)\n    bulk_adata.layers['normal_center'] = bulk_data.T.values\n    sample = np.zeros((cell_prop.shape[0],sc_data.shape[0]))\n    mapped_cor = []\n    sample_ori = np.zeros((cell_prop.shape[0],sc_data.shape[0]))\n    sc_mapping_dict = dict([(k,[]) for k in bulk_data.columns])\n    if multiprocessing:\n        if cpu_count()&lt;2:\n            cpu_num = cpu_count()\n        # compute person correlation and select sc according to person correlation.\n        print(f\"multiprocessing mode, cpu count is {cpu_num}\")\n        with Pool(int(cpu_num)) as p:\n            results = p.starmap(_bulk_mapping_parallel, [(i, cell_num.iloc[i,:], bulk_data, sc_data, cell_list, meta_dict, cellname_list, input_sc_data)\n             for i in range(cell_num.shape[0])])\n        # postprocessing\n        for i, (sample_ori_i,sample_i, mapped_cor_i, sc_mapping_dict_i) in enumerate(results):\n            sample_ori[i]= np.array(sample_ori_i)\n            sample[i] = np.array(sample_i)\n            mapped_cor.append(mapped_cor_i)\n            for k in sc_mapping_dict_i.keys():\n                sc_mapping_dict[k].extend(sc_mapping_dict_i[k])\n    else:\n        for index_num, (i, sample_num) in enumerate(tqdm(cell_num.iterrows())):\n            sample_cor = np.dot(bulk_data[i].values.reshape(1,bulk_data.shape[0]),sc_data.values)\n            cor_index = cell_list[np.argsort(sample_cor)]\n            for j, cellname in enumerate(cellname_list):\n                mask = np.isin(cor_index, meta_dict[cellname])\n                sub_cell = cor_index[mask]\n                sub_cell = sub_cell[:int(sample_num[j])]\n                sc_mapping_dict[i].extend(sub_cell)\n            print(f\"sample {i} done.\")\n            sample_ori[index_num,:] = input_sc_data.loc[:,sc_mapping_dict[i]].sum(axis=1)\n            sample[index_num,:] = sc_data.loc[:,sc_mapping_dict[i]].sum(axis=1)\n            mapped_cor_i = utils.pear(sample[index_num,:],bulk_data[i].values).item()\n            mapped_cor.append(mapped_cor_i)\n    print('initial mapping solution:',\"min correlation\", min(mapped_cor),\"average correlation\",np.mean(mapped_cor),\"max correlation\", max(mapped_cor))\n    bulk_adata.obsm['cell_number']=pd.DataFrame(cell_matrix,index=cell_prop.index,columns=cell_prop.columns)\n    bulk_adata.layers['mapping'] = sample/n_cell\n    bulk_adata.layers['mapping_ori'] = sample_ori/n_cell\n    if filter_gene:\n        from sklearn.metrics.pairwise import cosine_similarity\n        gene_list = []\n        similarity_list=[]\n        data_ori = pd.DataFrame(bulk_adata.X,index=bulk_adata.obs_names,columns=bulk_adata.var_names)\n        data_mapping = pd.DataFrame(bulk_adata.layers['mapping_ori'],index=bulk_adata.obs_names,columns=bulk_adata.var_names)\n        for gene in bulk_adata.var_names:\n            similarity = cosine_similarity(data_ori[gene].values.reshape(1, -1), data_mapping[gene].values.reshape(1, -1))\n            if similarity &gt; 0.6:\n                similarity_list.append(similarity[0][0])\n                gene_list.append(gene)\n        bulk_adata=bulk_adata[:,gene_list].copy()\n        print('Gene cosin similarity:',\"min value\", min(similarity_list),\"average value\",np.mean(similarity_list),\"max value\", max(similarity_list))\n        print(f'The number of reconstructed gene:{len(gene_list)}')  \n    print(f'Time to finish mapping: {round(time.perf_counter() - start_t, 2)} seconds')\n    print(\"=========================================================================================================================================\")\n    if save:\n        out_dir = utils.check_paths(f'{out_dir}/output')\n        df = pd.DataFrame([(k, v) for k, lst in sc_mapping_dict.items() for v in lst], columns=['sample_id', 'cell_id'])\n        df.to_csv(f\"{out_dir}/bulk_data_{project}_mapping.csv\")\n        bulk_adata.write_h5ad(f\"{out_dir}/bulk_data_{project}_mapping.h5ad\")\n\n    return df,bulk_adata\n</code></pre> <p><pre><code>def st_mapping(st_adata,\n               sc_adata,\n               out_dir,\n               project,\n               annotation_key,\n               **kwargs)\n</code></pre> </p> <p>Run spatial transcriptomics mapping with single-cell RNA-seq data.</p> <p>This function maps spatial transcriptomics (ST) data to single-cell RNA-seq (scRNA-seq) data. It aligns cell type compositions and estimates spatial distributions.</p> <p>Parameters:</p> Name Type Description Default <code>st_adata</code> <code>AnnData</code> <p>An :class:<code>~anndata.AnnData</code> object containing spatial transcriptomics data.</p> required <code>sc_adata</code> <code>AnnData</code> <p>An :class:<code>~anndata.AnnData</code> object containing single-cell RNA-seq data.</p> required <code>seed</code> <code>int, optional (default: 0)</code> <p>Seed for random number generation to ensure reproducibility.</p> required <code>annotation_key</code> <code>string, optional (default: 'celltype_minor')</code> <p>Key in <code>sc_adata</code> for cell type annotations.</p> required <code>sc_downsample</code> <code>bool, optional (default: False)</code> <p>Whether to downsample scRNA-seq data to a maximum number of transcripts per cell.</p> required <code>scRNA_max_transcripts_per_cell</code> <code>int, optional (default: 1500)</code> <p>Maximum number of transcripts per cell for downsampling.</p> required <code>sampling_method</code> <code>string, optional (default: 'duplicates')</code> <p>Method for sampling single cells based on cell type composition.</p> required <code>out_dir</code> <code>string, optional (default: '.')</code> <p>Directory to save output files.</p> required <code>project</code> <code>string, optional (default: 'test')</code> <p>Project name for output file naming.</p> required <code>mean_cell_numbers</code> <code>int, optional (default: 8)</code> <p>Average number of cells per spot used for estimation.</p> required <code>save_reconstructed_st</code> <code>bool, optional (default: True)</code> <p>Whether to save the reconstructed spatial transcriptomics data.</p> required <p>Returns:</p> Name Type Description <code>reconstructed_sc</code> <code>DataFrame</code> <p>DataFrame containing the mapping of single-cell IDs to spatial spot IDs.</p> Source code in <code>cytobulk\\tools\\_mapping.py</code> <pre><code>def st_mapping(st_adata,\n               sc_adata,\n               out_dir,\n               project,\n               annotation_key,\n               **kwargs):\n    \"\"\"\n    Run spatial transcriptomics mapping with single-cell RNA-seq data.\n\n    This function maps spatial transcriptomics (ST) data to single-cell RNA-seq (scRNA-seq) data. It aligns cell type compositions and estimates spatial distributions.\n\n    Parameters\n    ----------\n    st_adata : anndata.AnnData\n        An :class:`~anndata.AnnData` object containing spatial transcriptomics data.\n\n    sc_adata : anndata.AnnData\n        An :class:`~anndata.AnnData` object containing single-cell RNA-seq data.\n\n    seed : int, optional (default: 0)\n        Seed for random number generation to ensure reproducibility.\n\n    annotation_key : string, optional (default: 'celltype_minor')\n        Key in `sc_adata` for cell type annotations.\n\n    sc_downsample : bool, optional (default: False)\n        Whether to downsample scRNA-seq data to a maximum number of transcripts per cell.\n\n    scRNA_max_transcripts_per_cell : int, optional (default: 1500)\n        Maximum number of transcripts per cell for downsampling.\n\n    sampling_method : string, optional (default: 'duplicates')\n        Method for sampling single cells based on cell type composition.\n\n    out_dir : string, optional (default: '.')\n        Directory to save output files.\n\n    project : string, optional (default: 'test')\n        Project name for output file naming.\n\n    mean_cell_numbers : int, optional (default: 8)\n        Average number of cells per spot used for estimation.\n\n    save_reconstructed_st : bool, optional (default: True)\n        Whether to save the reconstructed spatial transcriptomics data.\n\n    Returns\n    -------\n    reconstructed_sc : pandas.DataFrame\n        DataFrame containing the mapping of single-cell IDs to spatial spot IDs.\n    \"\"\"\n    start_t = time.perf_counter()\n    print(\"=================================================================================================\")\n    print('Start to mapping bulk data with single cell dataset.')\n    reconstructed_sc=_run_st_mapping(st_adata = st_adata,\n                                     sc_adata = sc_adata,\n                                     out_dir = out_dir,\n                                     project = project,\n                                     annotation_key=annotation_key,\n                                     **kwargs)\n    print(f'Time to finish mapping: {round(time.perf_counter() - start_t, 2)} seconds')\n    print(\"=========================================================================================================================================\")\n\n    return reconstructed_sc\n</code></pre> <p><pre><code>def he_mapping(image_dir,\n               out_dir,\n               project,\n               lr_data = None,\n               sc_adata = None,\n               annotation_key=\"curated_celltype\",\n               k_neighbor=30,\n               alpha=0.5,\n               mapping_sc=True,\n               **kwargs)\n</code></pre> </p> <p>Run H&amp;E-stained image cell type mapping with single-cell RNA-seq data.</p> <p>This function predicts cell types from H&amp;E-stained histology images and aligns them with single-cell RNA-seq (scRNA-seq) data using optimal transport. It computes spatial distributions and matches cell types between the image and single-cell data.</p> <p>Parameters:</p> Name Type Description Default <code>image_dir</code> <code>str</code> <p>Path to the directory containing H&amp;E-stained images.</p> required <code>out_dir</code> <code>str</code> <p>Directory where the output files will be saved.</p> required <code>project</code> <code>str</code> <p>Name of the project, used for naming output files.</p> required <code>lr_data</code> <code>pandas.DataFrame, optional (default: None)</code> <p>A DataFrame containing ligand-receptor pair data with columns 'ligand' and 'receptor'.</p> <code>None</code> <code>sc_adata</code> <code>anndata.AnnData, optional (default: None)</code> <p>An :class:<code>~anndata.AnnData</code> object containing single-cell RNA-seq data with gene expression profiles.</p> <code>None</code> <code>annotation_key</code> <code>str, optional (default: \"curated_celltype\")</code> <p>Key in <code>sc_adata.obs</code> for cell type annotations.</p> <code>'curated_celltype'</code> <code>k_neighbor</code> <code>int, optional (default: 30)</code> <p>Number of neighbors to consider when constructing the graph for H&amp;E image data.</p> <code>30</code> <code>alpha</code> <code>float, optional (default: 0.5)</code> <p>Trade-off parameter for the Fused Gromov-Wasserstein optimal transport, controlling the balance between graph structure and feature matching (value between 0 and 1).</p> <code>0.5</code> <code>mapping_sc</code> <code>bool, optional (default: True)</code> <p>Whether to perform mapping between H&amp;E image cell data and single-cell RNA-seq data. If False, only H&amp;E image cell type predictions are returned.</p> <code>True</code> <code>**kwargs</code> <code>dict</code> <p>Additional arguments (not used in this implementation).</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>cell_coordinates</code> <code>DataFrame</code> <p>DataFrame containing cell coordinates and their predicted cell types from H&amp;E-stained images.</p> <code>df</code> <code>DataFrame</code> <p>DataFrame containing matching results between H&amp;E image cells and single-cell data, including spatial coordinates, cell types, and matched single-cell IDs.</p> <code>filtered_adata</code> <code>AnnData</code> <p>A filtered :class:<code>~anndata.AnnData</code> object containing only the single-cell data that matches with cells from H&amp;E-stained images.</p> Source code in <code>cytobulk\\tools\\_mapping.py</code> <pre><code>def he_mapping(image_dir,\n               out_dir,\n               project,\n               lr_data = None,\n               sc_adata = None,\n               annotation_key=\"curated_celltype\",\n               k_neighbor=30,\n               alpha=0.5,\n               mapping_sc=True,\n               **kwargs):\n\n    \"\"\"\n    Run H&amp;E-stained image cell type mapping with single-cell RNA-seq data.\n\n    This function predicts cell types from H&amp;E-stained histology images and aligns them with single-cell RNA-seq (scRNA-seq) data using optimal transport. It computes spatial distributions and matches cell types between the image and single-cell data.\n\n    Parameters\n    ----------\n    image_dir : str\n        Path to the directory containing H&amp;E-stained images.\n\n    out_dir : str\n        Directory where the output files will be saved.\n\n    project : str\n        Name of the project, used for naming output files.\n\n    lr_data : pandas.DataFrame, optional (default: None)\n        A DataFrame containing ligand-receptor pair data with columns 'ligand' and 'receptor'.\n\n    sc_adata : anndata.AnnData, optional (default: None)\n        An :class:`~anndata.AnnData` object containing single-cell RNA-seq data with gene expression profiles.\n\n    annotation_key : str, optional (default: \"curated_celltype\")\n        Key in `sc_adata.obs` for cell type annotations.\n\n    k_neighbor : int, optional (default: 30)\n        Number of neighbors to consider when constructing the graph for H&amp;E image data.\n\n    alpha : float, optional (default: 0.5)\n        Trade-off parameter for the Fused Gromov-Wasserstein optimal transport, controlling the balance between graph structure and feature matching (value between 0 and 1).\n\n    mapping_sc : bool, optional (default: True)\n        Whether to perform mapping between H&amp;E image cell data and single-cell RNA-seq data. If False, only H&amp;E image cell type predictions are returned.\n\n    **kwargs : dict\n        Additional arguments (not used in this implementation).\n\n    Returns\n    -------\n    cell_coordinates : pandas.DataFrame\n        DataFrame containing cell coordinates and their predicted cell types from H&amp;E-stained images.\n\n    df : pandas.DataFrame\n        DataFrame containing matching results between H&amp;E image cells and single-cell data, including spatial coordinates, cell types, and matched single-cell IDs.\n\n    filtered_adata : anndata.AnnData\n        A filtered :class:`~anndata.AnnData` object containing only the single-cell data that matches with cells from H&amp;E-stained images.\n    \"\"\"\n    start_t = time.perf_counter()\n    file_dir = resource_filename(__name__, 'model/pretrained_models/')\n    file_name = 'DeepCMorph_Datasets_Combined_41_classes_acc_8159.pth'\n\n    # The download URL for the file (replace with the actual URL)\n    download_url = \"https://data.vision.ee.ethz.ch/ihnatova/public/DeepCMorph/DeepCMorph_Pan_Cancer_Regularized_32_classes_acc_8200.pth\"\n\n    # Ensure the file exists; if not, download it\n    get.ensure_file_exists(file_dir, file_name, download_url)\n    cell_coordinates = inference_cell_type_from_he_image(image_dir,\n                                                         out_dir,\n                                                         project)\n    if mapping_sc:\n        print(\"preprocessing of single cell data\")\n        lr_genes = np.unique(np.concatenate((lr_data['ligand'].values, lr_data['receptor'].values)))\n        sc.pp.filter_cells(sc_adata, min_genes=200)  # filter\n        sc.pp.filter_genes(sc_adata, min_cells=3)   # filter\n        sc.pp.normalize_total(sc_adata, target_sum=1e4)  # nor\n        sc.pp.log1p(sc_adata)  # log\n        common_gene = np.intersect1d(lr_genes, sc_adata.var_names)\n        sc_adata = sc_adata[:, common_gene].copy()\n        lr_data = lr_data[\n            (lr_data['ligand'].isin(common_gene)) &amp; (lr_data['receptor'].isin(common_gene))\n        ].copy()\n\n        adata_cell_types = set(sc_adata.obs[annotation_key].unique())\n        coordinates_cell_types = set(cell_coordinates[\"cell_type\"].unique())\n\n\n        # common_celltype\n        common_cell_types = adata_cell_types.intersection(coordinates_cell_types)\n        print(f\"Common cell types: {common_cell_types}\")\n\n        # filter adata and cell_coordinates\n        sc_adata = sc_adata[sc_adata.obs[annotation_key].isin(common_cell_types), :].copy()\n        cell_coordinates = cell_coordinates[cell_coordinates[\"cell_type\"].isin(common_cell_types)].copy()\n\n\n        print(\"loading graph for H&amp;E image...\")\n        graph1_adj, graph1_labels = load_graph1(cell_coordinates,k=k_neighbor)\n\n        print(\"loading graph for single cell data with LR affinity...\")\n        graph2_dist, graph2_labels,sc_adata = load_graph2_with_LR_affinity(sc_adata, \n                                                                graph1_labels,\n                                                                lr_data,\n                                                                annotation_key)\n\n        graph2_dist = np.nan_to_num(graph2_dist, nan=np.nanmax(graph2_dist), posinf=np.nanmax(graph2_dist), neginf=0)\n\n        print(\"compute cost matrix\")\n        cost_matrix = construct_cost_matrix(graph1_labels, graph2_labels)\n\n        cost_matrix = np.nan_to_num(cost_matrix, nan=np.nanmax(cost_matrix), posinf=np.nanmax(cost_matrix), neginf=0)\n\n        print(\"optimal transport...\")\n        p = np.ones(graph1_adj.shape[0]) / graph1_adj.shape[0]\n        q = np.ones(graph2_dist.shape[0]) / graph2_dist.shape[0]\n\n        p = np.nan_to_num(p, nan=1.0 / len(p), posinf=1.0 / len(p), neginf=0)\n        q = np.nan_to_num(q, nan=1.0 / len(q), posinf=1.0 / len(q), neginf=0)\n\n        # Fused Gromov-Wasserstein\n        '''\n        gw_trans, log = ot.gromov.BAPG_fused_gromov_wasserstein(\n            cost_matrix, graph1_adj, graph2_dist, p, q, alpha=alpha, log=True\n        )\n        '''\n        ot_plan = ot.gromov.fused_gromov_wasserstein(\n        cost_matrix, graph1_adj, graph2_dist, p, q, alpha=alpha, loss_fun='square_loss'\n        )\n        print(f'Time to finish mapping: {round(time.perf_counter() - start_t, 2)} seconds')\n        print(\"=========================================================================================================================================\")\n        # Step 5: matching file\n        print(\"build matching file...\")\n        locations = list(range(graph1_adj.shape[0])) \n        cells = list(range(graph2_dist.shape[0])) \n        matches = extract_matching_relationships(ot_plan, locations, cells)\n        df = pd.DataFrame(matches, columns=[\"location\", \"cell\"])\n        location_mapping = cell_coordinates[[\"x\", \"y\"]].to_dict(orient=\"index\")\n        df[\"x\"] = df[\"location\"].map(lambda c: cell_coordinates['x'].values[c])\n        df[\"y\"] = df[\"location\"].map(lambda c: cell_coordinates['y'].values[c])\n        df[\"he_cell_type\"] = df[\"location\"].map(lambda c: cell_coordinates['cell_type'].values[c])\n        df[\"cell_type\"] = df[\"cell\"].map(lambda c: graph2_labels[c])\n        df[\"cell_id\"] = df[\"cell\"].map(lambda c: sc_adata.obs_names[c])\n        df.to_csv(f\"{out_dir}/{project}_matching_results.csv\", index=False)\n        df_cell_ids = df['cell_id']\n        adata_cell_ids = sc_adata.obs_names \n        common_cell_ids = set(df_cell_ids).intersection(set(adata_cell_ids))\n        filtered_df = df[df['cell_id'].isin(common_cell_ids)].copy()\n        filtered_adata = sc_adata[sc_adata.obs_names.isin(common_cell_ids)].copy()\n        filtered_df = filtered_df.set_index('cell_id')\n        #filtered_adata.obs = pd.DataFrame()\n        filtered_adata.obs = filtered_df\n        filtered_adata.var.index.name = \"gene\"\n        filtered_adata.write_h5ad(f\"{out_dir}/{project}_matching_adata.h5ad\")\n        return cell_coordinates,df,filtered_adata\n    else:\n        return cell_coordinates\n</code></pre>"},{"location":"tools/_segmentation/","title":"tools._segmentation","text":"<p><pre><code>def predict_cell_num(st_adata_path,\n                     diameter,\n                     save_png_result=False,\n                     model_type='cyto3',\n                     out_path='./',\n                     cellprob_threshold=1,\n                     save=True)\n</code></pre> </p> <p>Predicts cell numbers from spatial transcriptomics data using Cellpose.</p> <p>Parameters:</p> Name Type Description Default <code>st_adata</code> <code>AnnData</code> <p>Spatial transcriptomics AnnData object.</p> required <code>library_ids</code> <code>string</code> <p>Identifier for the library in the AnnData object.</p> <code>'library_ids'</code> <code>diameter</code> <code>int</code> <p>Estimated diameter of the cells to be detected.</p> <code>None</code> <code>save_png_result</code> <code>bool</code> <p>If True, saves the segmentation results as PNG files.</p> <code>False</code> <code>model_type</code> <code>string</code> <p>Type of Cellpose model to use. Default is 'cyto3'.</p> <code>'cyto3'</code> <code>out_path</code> <code>string</code> <p>Directory to save the output files. Default is './'.</p> required <code>cellprob_threshold</code> <code>float</code> <p>Cell probability threshold for Cellpose. Default is 1.</p> <code>0.4</code> <code>save</code> <code>bool</code> <p>If True, saves the results to an h5ad file. Default is True.</p> <code>True</code> <p>Returns:</p> Name Type Description <code>st_adata</code> <code>AnnData</code> <p>Updated AnnData object with predicted cell numbers.</p> <code>cell_pos</code> <code>DataFrame</code> <p>DataFrame containing cell positions.</p> Source code in <code>cytobulk\\tools\\_segmentation.py</code> <pre><code>def predict_cell_num(st_adata,\n                     library_ids=\"library_ids\",\n                     project=\"test\",\n                     diameter=None,\n                     save_png_result=False,\n                     model_type='cyto3',\n                     out_dir='.',\n                     cellprob_threshold=0.4,\n                     save=True):\n\n    '''\n    Predicts cell numbers from spatial transcriptomics data using Cellpose.\n\n    Parameters\n    ----------\n    st_adata : AnnData\n        Spatial transcriptomics AnnData object.\n\n    library_ids : string\n        Identifier for the library in the AnnData object.\n\n    diameter : int, optional\n        Estimated diameter of the cells to be detected.\n\n    save_png_result : bool, optional\n        If True, saves the segmentation results as PNG files.\n\n    model_type : string, optional\n        Type of Cellpose model to use. Default is 'cyto3'.\n\n    out_path : string, optional\n        Directory to save the output files. Default is './'.\n\n    cellprob_threshold : float, optional\n        Cell probability threshold for Cellpose. Default is 1.\n\n    save : bool, optional\n        If True, saves the results to an h5ad file. Default is True.\n\n    Returns\n    -------\n    st_adata : AnnData\n        Updated AnnData object with predicted cell numbers.\n\n    cell_pos : pandas.DataFrame\n        DataFrame containing cell positions.\n    '''\n    from cellpose import models, io, plot\n    from tqdm import tqdm\n\n    print('-----Initializing model...')\n    model = models.Cellpose(model_type=model_type)\n    ch = [0, 0] # NOTE: here we set all images to greyscale\n\n    print('-----Reading files...')\n    img = rgb2grey(st_adata.uns['spatial'][library_ids]['images']['hires'])\n\n\n    coord = st_adata.obsm['spatial']*st_adata.uns['spatial'][library_ids]['scalefactors']['tissue_hires_scalef']\n    spots = pd.DataFrame(coord, columns=[\"X\", \"Y\"])\n    crop_r = int(st_adata.uns['spatial'][library_ids]['scalefactors']['spot_diameter_fullres']*st_adata.uns['spatial'][library_ids]['scalefactors']['tissue_hires_scalef'])\n    #crop_r = int(st_adata.uns['spatial'][library_ids]['scalefactors']['spot_diameter_fullres'])\n    half_r = crop_r // 2 + 5\n    print(half_r)\n    print('-----Predicting cell number...')\n    ret = pd.DataFrame(data={'X':[], 'Y':[], 'cell_num':[]})\n    cell_pos = pd.DataFrame(data={'id':[], 'X':[], 'Y':[]})\n    for _, row in tqdm(spots.iterrows()):\n        x = int(row[Const.PIX_X]); y = int(row[Const.PIX_Y])\n        x_max = min(x+half_r, img.shape[0]-1)\n        x_min = max(x-half_r, 0)\n        y_max = min(y+half_r, img.shape[1]-1)\n        y_min = max(y-half_r, 0)\n\n        tile = img[x_min:x_max, y_min:y_max]\n        masks, flows, styles, diams = model.eval(tile, diameter=diameter, channels=ch,  cellprob_threshold=cellprob_threshold)\n        cell_num = len(np.unique(masks))\n        ret.loc[len(ret.index)] = [x, y, cell_num]\n        for i in range(cell_num):\n            xi = np.where(masks == i)[0].mean()\n            yi = np.where(masks == i)[1].mean()\n            cell_pos.loc[len(cell_pos.index)] = [f\"spot{_}_cell{i}\", xi, yi]\n\n        if save_png_result:\n            fig = plt.figure()\n            plot.show_segmentation(fig, tile, masks, flows[0], channels=ch)\n            plt.tight_layout()\n            #plt.savefig(save_png_result.replace('.', f'_{x}x{y}.'))\n            plt.savefig(f\"{out_dir}/figures/{_}_segmentation_result.png\")\n\n    st_adata.obsm[\"cell_num\"] = (ret[\"cell_num\"]).to_numpy()\n    st_adata.uns[\"seg_cell_pos\"] = cell_pos\n    ret[\"cell_num\"].to_csv(f\"{out_dir}/output/{project}_cell_num.csv\")\n    cell_pos.to_csv(f\"{out_dir}/output/{project}_cell_pos.csv\")\n    st_adata.write_h5ad(f\"{out_dir}/output/segmentation_adata.h5ad\")\n    return st_adata, cell_pos\n</code></pre>"},{"location":"tutorials/he_deconv_anno/","title":"ST data deconvolution and spot annotation","text":"<p>If using an external R installation (may not be necessary on Linux systems).</p> <pre><code>import os\nos.environ['R_HOME'] = 'C:/Program Files/R/R-4.4.1'\n</code></pre> <pre><code>import os\nimport sys\nimport cytobulk as ct\nimport scanpy as sc\nimport pandas as pd\nimport warnings\nwarnings.filterwarnings(\"ignore\")\n</code></pre> <p>Load the mouse mob reference single cell data, e.g. GSE121891 [Download data]. and ST data from Stahl, Patrik L., et al.[Download data].</p> <pre><code>sc_adata = sc.read_h5ad(\"C:/Users/wangxueying/project/CytoBulk/case/mouse_mob/input/sc_layer_mob.h5ad\")\nst_adata = sc.read_h5ad(\"C:/Users/wangxueying/project/CytoBulk/case/mouse_mob/input/st_mob.h5ad\")\n</code></pre> <p>If you want to use the pretrained model, please download the folder, extract it, and set the path of the extracted folder as the out_dir parameter. [Download] This will help you skip the training steps.</p> <pre><code>deconv_result,deconv_adata = ct.tl.st_deconv(st_adata = st_adata,\n                                             sc_adata = sc_adata,\n                                             annotation_key =\"subtype\",\n                                             out_dir=\"C:/Users/wangxueying/project/CytoBulk/case/MOB_layer\",\n                                             dataset_name=\"MOB_layer\",\n                                             different_source=True,\n                                             n_cell=15)\n</code></pre> <pre><code>deconv_result.head(5)\n</code></pre> EPL GC MTC OSN PGC GTCCGATATGATTGCCGC 0.221902 0.624702 0.107771 0.045624 0.000000 ATGAGCCGGGTTCATCTT 0.075856 0.668691 0.090633 0.061275 0.103544 TGAGGCACTCTGTTGGGA 0.042809 0.042166 0.262430 0.212727 0.439867 ATGATTAGTCGCCATTCG 0.039683 0.074653 0.581873 0.104038 0.199753 ACTTGAGGGTAGATGTTT 0.067761 0.106935 0.166045 0.487240 0.172019 <pre><code>ct.plots.celltype_fraction_pie(adata=deconv_adata,\n                                scale_facter_x=5,\n                                scale_factor_y=5,\n                                out_dir=\"C:/Users/wangxueying/project/CytoBulk/case/MOB_layer\",\n                                rotation_angle=225)\n</code></pre> <pre><code>ct.plots.celltype_fraction_heatmap(adata=deconv_adata,\n                                    label='OSN',\n                                    out_dir=\"C:/Users/wangxueying/project/CytoBulk/case/MOB_layer\",\n                                    rotation_angle=225)\n</code></pre> <pre><code>ct.plots.paired_violin(adata=deconv_adata,\n                        label='OSN',\n                        gene='Kctd12',\n                        out_dir=\"C:/Users/wangxueying/project/CytoBulk/case/mouse_mob_1/output/output\")\n</code></pre>"},{"location":"tutorials/he_deconv_anno/#st-data-deconvolution-and-spot-annotation","title":"ST data deconvolution and spot annotation","text":""},{"location":"tutorials/he_deconv_anno/#import-the-packages","title":"import the packages","text":""},{"location":"tutorials/he_deconv_anno/#load-scrna-seq-and-st-data","title":"Load scRNA-seq and ST data","text":""},{"location":"tutorials/he_deconv_anno/#deconvolute-st-data-with-sc-rna-seq-as-the-reference","title":"Deconvolute ST data with sc-RNA seq as the reference.","text":""},{"location":"tutorials/he_deconv_anno/#visualization-of-spot-annotation-results","title":"Visualization of spot annotation results","text":""},{"location":"tutorials/mapping_he_sc/","title":"H&E cell prediction and integration with scRNA-seq","text":"<p>If using an external R installation (may not be necessary on Linux systems).</p> <pre><code>import os\nos.environ['R_HOME'] = r'C:\\Program Files\\R\\R-4.4.1'\n</code></pre> <pre><code>import os\nimport cytobulk as ct\nimport scanpy as sc\nimport pandas as pd\nimport warnings\nwarnings.filterwarnings(\"ignore\")\n</code></pre> <p>If you want to perform cell segmentation on HE images and integrate it with single-cell data, please complete the following steps. Otherwise, you can skip this section.</p> <pre><code>sc_adata = sc.read_h5ad(\"C:/Users/wangxueying/project/CytoBulk/case/he_image/svs/TCGA_LUSC/sub_HTAN_MSK.h5ad\")\n</code></pre> <p>Please ensure that your sc_adata contains at least one of the following six cell types: lymphocytes, epithelial cells, plasma cells, neutrophils, eosinophils, and connective tissue</p> <pre><code>sc_adata.obs['he_cell_type']\n</code></pre> <pre>\n<code>Cell\nRU1311A_T_1_165945547864806                 lymphocytes\nRU1181B_169649541863334                      epithelial\nRU1108a_RPMI_164761076713396                 epithelial\nRU1145_133982151621558                      lymphocytes\nRU1145_170180373265117                       epithelial\n                                               ...     \nRU1145_161890937236718                      lymphocytes\nRU1108a_RPMI_160785132370275                 epithelial\nRU1108a_Bambanker_Frozen_231897696155998     epithelial\nRU1181B_236168014327141                      epithelial\nRU1145_120772933872502                       epithelial\nName: he_cell_type, Length: 31165, dtype: category\nCategories (5, object): ['connective tissue', 'epithelial', 'lymphocytes', 'neutrophils', 'plasma cells']</code>\n</pre> <pre><code>lr_data = pd.read_csv(\"C:/Users/wangxueying/project/CytoBulk/case/he_image/svs/input/lrpairs.csv\")\n</code></pre> <p>We will use the CellChatDB ligand-receptor database here. You can also use any lr pair data, as long as it follows the format below (the ligand and receptor columns are required).</p> <pre><code>lr_data.head(5)\n</code></pre> ligand receptor species 0 SEMA3F PLXNA3 Human 1 SEMA3F PLXNA1 Human 2 SEMA3F NRP1 Human 3 SEMA3F NRP2 Human 4 CX3CL1 CX3CR1 Human <p>For the H&amp;E image used for prediction, here we take the H&amp;E image of the TCGA-56-8626 sample as an example. The input H&amp;E image format is .svs. First, we crop a region with a width of 2240 and a height of 2240, centered at center x 10000 and center y 11200. This region is then split into smaller sub-images, each with a width of 224 and a height of 224. [Download data]</p> <pre><code>ct.pp.process_svs_image(\n    svs_path = r\"C:\\Users\\wangxueying\\project\\CytoBulk\\case\\he_image\\svs\\image\\TCGA-37-4132.svs\",\n    output_dir = r\"C:\\Users\\wangxueying\\project\\CytoBulk\\case\\he_image\\svs\\input\\demo_split\",\n    crop_size=224, magnification=1,center_x=10000,center_y=11200,fold_width=10,fold_height=10)\n</code></pre> <pre>\n<code>Original image size: 26001x21271\nImage center: (10000, 11200)\nCrop region: Start=(8880, 10080), Size=(2240, 2240)\n</code>\n</pre> <pre>\n<code>Enlarged image size: (2240, 2240)\n</code>\n</pre> <p>If your image is in another format, you can split it yourself to generate a folder containing sub-images. Each subfolder should be named after the starting x and y coordinates of the cropped images. Inside each subfolder, the split images should be stored.</p> <ul> <li> <p>Each subfolder name corresponds to the starting x and y coordinates (e.g., 0_0, 0_224, etc.).</p> </li> <li> <p>Inside each subfolder, the cropped images are stored, such as 0.jpg.</p> </li> </ul> <p>If you only want to perform cell segmentation and cell type prediction within the H&amp;E image without performing single-cell mapping, you can directly use the following function.</p> <pre><code>cell_coordinates = ct.tl.he_mapping(image_dir=r\"C:\\Users\\wangxueying\\project\\CytoBulk\\case\\he_image\\svs\\input\\demo_split\",\n                                    out_dir = r\"C:\\Users\\wangxueying\\project\\CytoBulk\\case\\he_image\\svs\\out\\demo\",\n                                    project = \"demo\",\n                                    lr_data = None,\n                                    sc_adata = None,\n                                    annotation_key=\"he_cell_type\",\n                                    k_neighbor=30,\n                                    alpha=0.5,\n                                    mapping_sc=False)\n</code></pre> <pre>\n<code>File already exists: c:\\Users\\wangxueying\\anaconda\\envs\\cytobulk\\lib\\site-packages\\cytobulk\\tools\\model\\pretrained_models\\DeepCMorph_Datasets_Combined_41_classes_acc_8159.pth\nModel loaded, unexpected keys: []\nGenerating segmentation and classification maps for sample images\nAll visual results saved\nCombine results\nSkipping invalid file name: combinded_cent.txt\nData successfully written to C:\\Users\\wangxueying\\project\\CytoBulk\\case\\he_image\\svs\\out\\demo\\combinded_cent.txt\nSave file done\n</code>\n</pre> <p>If you encounter the following error while running the ct.tl.he_mapping function: _pickle.UnpicklingError: invalid load key, '&lt;'.</p> <p>This error occurs because the pretrained model file was not fully downloaded, resulting in a corrupted or incomplete file. To resolve this issue, follow the steps below to manually download the model file and place it in the correct location. [Download model]</p> <p>The predicted cell types and their corresponding coordinates are stored in the following format. The file is located in the out_dir directory, and its name is cell_coordinates.txt.</p> <pre><code>cell_coordinates.head(5)\n</code></pre> data_set x y cell_type 0 demo 17 1 Epithelial Cells 1 demo 33 2 Epithelial Cells 2 demo 129 4 Epithelial Cells 3 demo 34 12 Epithelial Cells 4 demo 218 12 Epithelial Cells <p>Next, use the built-in function to visualize the results.</p> <pre><code>ct.pl.he_cell_type(cell_coordinates,out_dir=r\"C:\\Users\\wangxueying\\project\\CytoBulk\\case\\he_image\\svs\\out\\demo\")\n</code></pre> <p>If you want to perform cell segmentation and cell type prediction within the H&amp;E image, as well as conduct single-cell mapping, please refer to the following function.</p> <p>The predicted cell types from the H&amp;E image include: Eosinophils, Plasma Cells, Connective Tissue, Epithelial Cells, Neutrophils, and Lymphocytes. First, ensure that your dataset's cell type labels include at least one of these types. You can use the following code as a reference to map your existing cell type labels to the required format:</p> <pre><code>mapping = {\n    'plasma cells': 'Plasma Cells',\n    'connective tissue': 'Connective Tissue',\n    'epithelial': 'Epithelial Cells',\n    'neutrophils': 'Neutrophils',\n    'lymphocytes': 'Lymphocytes'}\n\nsc_adata.obs['he_cell_type'] = sc_adata.obs['he_cell_type'].replace(mapping)\n</code></pre> <pre><code>cell_coordinates,df,filtered_adata = ct.tl.he_mapping(image_dir=r\"C:\\Users\\wangxueying\\project\\CytoBulk\\case\\he_image\\svs\\input\\demo_split\",\n                                            out_dir = r\"C:\\Users\\wangxueying\\project\\CytoBulk\\case\\he_image\\svs\\out\\demo\",\n                                            project = \"demo\",\n                                            lr_data = lr_data,\n                                            sc_adata = sc_adata,\n                                            annotation_key=\"he_cell_type\",\n                                            k_neighbor=30,\n                                            alpha=0.5,\n                                            mapping_sc=True)\n</code></pre> <pre>\n<code>File already exists: c:\\Users\\wangxueying\\anaconda\\envs\\cytobulk\\lib\\site-packages\\cytobulk\\tools\\model\\pretrained_models\\DeepCMorph_Datasets_Combined_41_classes_acc_8159.pth\nprint(f'{out_dir}/combinded_cent.txt already exists, skipping prediction.')\npreprocessing of single cell data\nCommon cell types: {'Lymphocytes', 'Connective Tissue', 'Epithelial Cells', 'Plasma Cells', 'Neutrophils'}\nloading graph for H&amp;E image...\nloading graph for single cell data with LR affinity...\nsample single cells according to predicted label\ncompute LR affinity\ncompute cost matrix\noptimal transport...\nTime to finish mapping: 201.66 seconds\n=========================================================================================================================================\nbuild matching file...\n</code>\n</pre> <p>Here, df and filtered_adata.obs store the single-cell cell IDs and their assigned coordinates.</p> <pre><code>filtered_adata.obs.head(5)\n</code></pre> location cell x y he_cell_type cell_type cell_id RU426B_164640655824627 0 2453 17 1 Epithelial Cells Epithelial Cells RU1229A_Frozen_228044332743404 1 1512 33 2 Epithelial Cells Epithelial Cells RU1066_129565685888750 2 2273 129 4 Epithelial Cells Epithelial Cells RU426B_166407915399029 3 1954 34 12 Epithelial Cells Epithelial Cells RU1066_126293994555309 4 1697 218 12 Epithelial Cells Epithelial Cells"},{"location":"tutorials/mapping_he_sc/#he-cell-prediction-and-integration-with-scrna-seq-on-tcga-data","title":"H&amp;E cell prediction and integration with scRNA-seq on TCGA data","text":""},{"location":"tutorials/mapping_he_sc/#import-the-packages","title":"import the packages","text":""},{"location":"tutorials/mapping_he_sc/#load-sc-rna-seq-data-and-ligand-receptor-data-optional","title":"Load sc-RNA seq data and ligand receptor data (optional)","text":""},{"location":"tutorials/mapping_he_sc/#load-the-reference-single-cell-data-eg-htan-msk-data-download-data","title":"Load the reference single cell data, e.g. HTAN MSK data. [Download data]","text":""},{"location":"tutorials/mapping_he_sc/#load-the-reference-ligand-receptor-data-eg-cellchatdb-ligand-receptor-database-download-data","title":"Load the reference ligand receptor data. e.g. CellChatDB ligand-receptor database. [Download data]","text":""},{"location":"tutorials/mapping_he_sc/#preprocess-he-image","title":"Preprocess H&amp;E image","text":""},{"location":"tutorials/mapping_he_sc/#predict-cell-type-labels-from-he-image","title":"Predict cell type labels from H&amp;E image","text":""},{"location":"tutorials/mapping_he_sc/#mapping-scrna-seq-data-on-he-image","title":"Mapping scRNA-seq data on H&amp;E image","text":""},{"location":"tutorials/mapping_sc_bulk/","title":"Bulk deconvolution and mapping with scRNA-seq","text":"<p>If using an external R installation (may not be necessary on Linux systems).</p> <pre><code>import os\nos.environ['R_HOME'] = r'C:\\Program Files\\R\\R-4.4.1'\n</code></pre> <pre><code>import os\nimport cytobulk as ct\nimport scanpy as sc\nimport pandas as pd\nimport warnings\nwarnings.filterwarnings(\"ignore\")\n</code></pre> <p>Load the reference single cell data, e.g. HTAN MSK data [Download data]. and TCGA LUSC data  [Download data].</p> <pre><code>sc_adata = sc.read_h5ad(\"C:/Users/wangxueying/project/CytoBulk/case/TCGA_LUSC/input/sub_HTAN_MSK.h5ad\")\nsc_adata_ori = sc_adata.copy()\nbulk_adata = sc.read_h5ad(\"C:/Users/wangxueying/project/CytoBulk/case/TCGA_LUSC/input/TCGA_LUSC.h5ad\")\n</code></pre> <p>The cell type information is be stored in sc_adata.obs['he_cell_type']</p> <pre><code>sc_adata.obs['he_cell_type'].value_counts()\n</code></pre> <pre>\n<code>he_cell_type\nepithelial           25988\nlymphocytes           4535\nconnective tissue      565\nneutrophils             69\nplasma cells             8\nName: count, dtype: int64</code>\n</pre> <p>If you want to use the pretrained model, please download the folder, extract it, and set the path of the extracted folder as the out_dir parameter. [Download] This will help you skip the training steps.</p> <pre><code>deconv_result,deconv_adata = ct.tl.bulk_deconv(bulk_data = bulk_adata,\n                                                sc_adata = sc_adata,\n                                                annotation_key =\"he_cell_type\",\n                                                out_dir=r\"C:\\Users\\wangxueying\\project\\CytoBulk\\case\\TCGA_LUSC\\TCGA_LUSC_2000\",\n                                                dataset_name=\"lusc\",\n                                                different_source=True,\n                                                downsampling=True,\n                                                n_cell=2000)\n</code></pre> <pre><code>deconv_result.head(5)\n</code></pre> connective tissue epithelial lymphocytes neutrophils plasma cells TCGA-18-3421 0.273443 0.176402 0.199808 0.204587 0.130384 TCGA-37-4133 0.282663 0.193125 0.156352 0.146849 0.171124 TCGA-L3-A524 0.337083 0.295797 0.119766 0.124372 0.121685 TCGA-56-A4ZK 0.322920 0.144941 0.182277 0.145558 0.146625 TCGA-39-5027 0.241746 0.491989 0.093591 0.133225 0.109625 <p>If you want to use multithreading for mapping, you can set multiprocessing=True and specify the number of CPUs to use with the cpu_num parameter.</p> <pre><code>reconstructed_cell, reconstructed_adata = ct.tl.bulk_mapping(bulk_adata = deconv_adata,\n                                                            sc_adata = sc_adata,\n                                                            out_dir=\"/data1/wangxueying/cytobulk/out/TCGA_LUSC_2000\",\n                                                            project=\"TCGA_LUSC\",\n                                                            n_cell=2000,\n                                                            annotation_key='he_cell_type',\n                                                            multiprocessing=False)\n</code></pre> <p>The matching relationship between single cells and bulk samples is stored in reconstructed_cell. The data assigned to the same bulk sample is aggregated, and the new expression values are stored in reconstructed_adata.layers['mapping_ori'], while the original expression values are stored in reconstructed_adata.X.</p> <pre><code>reconstructed_cell.head(5)\n</code></pre> sample_id cell_id 0 TCGA-18-3421 RU426B_197057083469109 1 TCGA-18-3421 RU426B_135693665261491 2 TCGA-18-3421 RU1144_T_236768069871899 3 TCGA-18-3421 RU1311A_T_1_130539716504350 4 TCGA-18-3421 RU1195A_236107999337252 <p>Load the marker gene data across cell types. [Download st data]</p> <pre><code>marker_df = pd.read_csv(r\"C:\\Users\\wangxueying\\project\\CytoBulk\\case\\bulk_brca\\marker_gene_symbol.txt\", sep=\"\\t\",index_col=0)\n</code></pre> <pre><code>marker_df.head(5)\n</code></pre> score pvalue adj_pvalue cell_type ensg_id gene_symbol gene ENSG00000142089 13.354671 5.980232e-32 1.183209e-30 connective tissue ENSG00000142089 IFITM3 ENSG00000142089 -8.668920 5.285041e-18 1.676378e-17 epithelial ENSG00000142089 IFITM3 ENSG00000142089 -3.913898 9.135025e-05 1.656657e-04 lymphocytes ENSG00000142089 IFITM3 ENSG00000142089 -2.615495 1.768798e-02 2.432355e-02 neutrophils ENSG00000142089 IFITM3 ENSG00000142089 -0.253202 8.101615e-01 8.899934e-01 plasma cells ENSG00000142089 IFITM3 <pre><code>ct.pl.gene_similarity(reconstructed_adata, marker_df)\n</code></pre> <pre>\n<code>Processing cell_type: connective tissue\nProcessing cell_type: epithelial\nProcessing cell_type: lymphocytes\nProcessing cell_type: neutrophils\nProcessing cell_type: plasma cells\n</code>\n</pre> <pre>\n<code>&lt;module 'matplotlib.pyplot' from 'c:\\\\Users\\\\wangxueying\\\\anaconda\\\\envs\\\\cytobulk\\\\lib\\\\site-packages\\\\matplotlib\\\\pyplot.py'&gt;</code>\n</pre>"},{"location":"tutorials/mapping_sc_bulk/#integration-with-single-cell-and-tcga-bulk-data","title":"Integration with single cell and TCGA bulk data","text":""},{"location":"tutorials/mapping_sc_bulk/#import-the-packages","title":"import the packages","text":""},{"location":"tutorials/mapping_sc_bulk/#load-scrna-seq-and-bulk-data","title":"Load scRNA-seq and bulk data","text":""},{"location":"tutorials/mapping_sc_bulk/#deconvolute-bulk-data-with-sc-rna-seq-as-the-reference","title":"Deconvolute bulk data with sc-RNA seq as the reference.","text":""},{"location":"tutorials/mapping_sc_bulk/#mapping-scrna-seq-to-bulk-data","title":"Mapping scRNA-seq to bulk data","text":""},{"location":"tutorials/mapping_sc_bulk/#visulization-of-marker-gene-expression-similarity-between-original-and-reconstructed-data","title":"Visulization of marker gene expression similarity between original and reconstructed data","text":""},{"location":"tutorials/mapping_sc_st/","title":"ST deconvolution and mapping with scRNA-seq","text":"<p>If using an external R installation (may not be necessary on Linux systems).</p> <pre><code>import os\nos.environ['R_HOME'] = r'C:\\Program Files\\R\\R-4.4.1'\n</code></pre> <pre><code>import torch\nprint(torch.__version__)\n</code></pre> <pre>\n<code>2.5.1+cpu\n</code>\n</pre> <pre><code>import os\nimport cytobulk as ct\nimport scanpy as sc\nimport pandas as pd\nimport warnings\nwarnings.filterwarnings(\"ignore\")\n</code></pre> <p>Here we use the single-cell, spatial, and in situ data from Sarah E. B. Taylor et al. and utilize CytoBulk for integrating the datasets. [Download sc data] [Download st data]</p> <pre><code>sc_adata = sc.read_h5ad(\"C:/Users/wangxueying/project/CytoBulk/case/10x/input/sc_adata.h5ad\")\nsc_ori_adata = sc_adata.copy()\nst_adata = sc.read_h5ad(\"C:/Users/wangxueying/project/CytoBulk/case/10x/input/st_adata_sub_3.h5ad\")\n</code></pre> <p>The cell type information is stored in sc_adata.obs['cell_type]</p> <pre><code>sc_adata.obs['cell_type'].value_counts()\n</code></pre> <pre>\n<code>cell_type\nInvasive Tumor             4559\nMacrophages 1              2964\nCD4+ T Cells               2899\nStromal                    2609\nDCIS 2                     2159\nDCIS 1                     1862\nCD8+ T Cells               1843\nB Cells                    1463\nProlif Invasive Tumor      1329\nMyoepi ACTA2+              1235\nEndothelial                1055\nT Cell &amp; Tumor Hybrid      1003\nMacrophages 2               760\nMyoepi KRT15+               604\nStromal &amp; T Cell Hybrid     426\nPerivascular-Like           285\nIRF7+ DCs                   210\nLAMP3+ DCs                  103\nMast Cells                   92\nName: count, dtype: int64</code>\n</pre> <p>If you want to use the pretrained model, please download the folder, extract it, and set the path of the extracted folder as the out_dir parameter. [Download] This will help you skip the training steps.</p> <pre><code>deconv_result,deconv_adata = ct.tl.st_deconv(st_adata = st_adata,\n                            sc_adata = sc_adata,\n                            annotation_key =\"cell_type\",\n                            out_dir=\"C:/Users/wangxueying/project/CytoBulk/case/10x/sub3/demo\",\n                            dataset_name=\"BRCA_10X\",\n                            different_source=True,\n                            n_cell=10)\n</code></pre> <p>The scaled fraction values (where the sum of each row equals 1) are stored in deconv_result and deconv_h5ad.uns['deconv']. The raw data is stored in the out_dir/out_put folder with the file name project_name_prediction_frac.csv.</p> <pre><code>deconv_result.iloc[:5, :7]\n</code></pre> B Cells CD4+ T Cells CD8+ T Cells DCIS 1 DCIS 2 Endothelial IRF7+ DCs AACCACTGCCATAGCC-1 0.0 0.0 0.0 0.0 0.172999 0.000000 0.0 AACCGCCAGACTACTT-1 0.0 0.0 0.0 0.0 0.000000 0.000000 0.0 AACGAAGCGTGGAAGT-1 0.0 0.0 0.0 0.0 0.000000 0.028330 0.0 AACGAATTGACCGGTT-1 0.0 0.0 0.0 0.0 0.000000 0.146543 0.0 AACGACATTAAGATGG-1 0.0 0.0 0.0 0.0 0.000000 0.320166 0.0 <pre><code>deconv_adata.uns['deconv'].iloc[:5, :7]\n</code></pre> B Cells CD4+ T Cells CD8+ T Cells DCIS 1 DCIS 2 Endothelial IRF7+ DCs AACCACTGCCATAGCC-1 0.0 0.0 0.0 0.0 0.172999 0.000000 0.0 AACCGCCAGACTACTT-1 0.0 0.0 0.0 0.0 0.000000 0.000000 0.0 AACGAAGCGTGGAAGT-1 0.0 0.0 0.0 0.0 0.000000 0.028330 0.0 AACGAATTGACCGGTT-1 0.0 0.0 0.0 0.0 0.000000 0.146543 0.0 AACGACATTAAGATGG-1 0.0 0.0 0.0 0.0 0.000000 0.320166 0.0 <p>Spatial Visualization of Deconvolution Results</p> <pre><code>import matplotlib as mpl\ni='Stromal'\nplot_adata = deconv_adata.copy()\nplot_adata.obs=plot_adata.uns['deconv']\nmpl.rcdefaults()\nfig=sc.pl.spatial(\n    plot_adata,\n    color=i,\n    img_key=None,\n    alpha=1,\n    color_map='mako',\n    size=1.3,\n    title=f'BRCA_10X predicted {i}',\n    spot_size=150,\n    return_fig=True\n)\n</code></pre> <p>If the cell count information is not known beforehand, you can use ct.tl.predict_cell_num to segment HE images using Cellpose, or let the program perform an internal estimation. Here we use the cell count data collected from paper of Sarah E. B. Taylor et al.</p> <pre><code>cell_num = pd.read_csv(r\"C:\\Users\\wangxueying\\project\\CytoBulk\\case\\10x\\sub3\\cell_num_3.csv\",index_col=0)\ndeconv_adata=deconv_adata[cell_num.index,:]\ncell_num=cell_num.loc[deconv_adata.obs_names,:]\ndeconv_adata.obsm['cell_num'] = cell_num\ndeconv_adata.uns['deconv'] = deconv_adata.uns['deconv'].loc[deconv_adata.obs_names,:]\n</code></pre> <pre><code>deconv_adata.obsm['cell_num'].head(5)\n</code></pre> cell_num CCGTGGCGTCGGTGCT-1 54 TCCGTGTTCTGTTCTG-1 39 TCGTAAGGCGTTCAGG-1 57 CTGCCGATTGCGATGT-1 7 CTTCCGTCGCTGCATC-1 37 <pre><code>reconstructed_cell, reconstructed_adata = ct.tl.st_mapping(st_adata = deconv_adata,\n                                            sc_adata = sc_ori_adata,\n                                            out_dir=\"C:/Users/wangxueying/project/CytoBulk/case/10x/sub3/demo\",\n                                            project=\"BRCA_10X\",\n                                            annotation_key='cell_type')\n</code></pre> <pre>\n<code>=================================================================================================\nStart to mapping bulk data with single cell dataset.\nDown/up sample of scRNA-seq data according to estimated cell type fractions\nTime to down/up sample scRNA-seq data: 0.0 seconds\nTime to finish mapping: 316.4 seconds\n=========================================================================================================================================\n</code>\n</pre> <p>The matching relationship between cells and spots is stored in reconstructed_cell. For single cells mapped to the same spot, we aggregated their gene expression, and the aggregated expression is stored in reconstructed_adata. The original ST expression data is stored in reconstructed_adata.layers['original_st'].</p> <pre><code>reconstructed_cell.head(5)\n</code></pre> spot_id cell_id 0 CATTAGGATAGTGAAT-1 CTATTAGGTTCACCAG-1 1 CATTAGGATAGTGAAT-1 CACGAACCAATATGGT-1 2 CATTAGGATAGTGAAT-1 ATCCCAATCAGTAGCG-1 3 CATTAGGATAGTGAAT-1 CCCTGTTGTGGCCCAT-1 4 CATTAGGATAGTGAAT-1 AAAGTAGCAAATGACT-1 <p>Check the pearson correlation between original expression data and reconstructed expression data.</p> <pre><code>from scipy.stats import pearsonr\nimport numpy as np\ncorrelations = []\nfor spot in reconstructed_adata.obs_names:\n    if spot in reconstructed_adata.obs_names:\n        expr1 = reconstructed_adata[spot, :].X[0]\n        expr2 = reconstructed_adata.layers['original_st'][reconstructed_adata.obs_names.get_loc(spot), :]\n        #r, p = pearsonr(expr1.X[0], expr2.X[0])\n        r, p = pearsonr(expr1, expr2)\n        correlations.append((spot, r, p))\n\ncorrelations_df = pd.DataFrame(correlations, columns=['spot', 'Pearson R', 'pvalue'])\ncorrelations_df['X']=reconstructed_adata.obsm['spatial'][:,0]\ncorrelations_df['Y']=reconstructed_adata.obsm['spatial'][:,1]\ncorrelations_df.set_index('spot',inplace=True)\nreconstructed_adata.obs=correlations_df\n</code></pre> <pre><code>np.mean(correlations_df['Pearson R'])\n</code></pre> <pre>\n<code>0.691908648515156</code>\n</pre> <p>Visualization of correlation result</p> <pre><code>import matplotlib.pyplot as plt\nfig=sc.pl.spatial(\n    reconstructed_adata,\n    color='Pearson R',\n    img_key=None,\n    alpha=0.8,\n    size=2,\n    title=f'Reconstructed BRCA 10X \\nmean Pearson correlation = 0.692\\ngene number = 18,082',\n    return_fig=True,\n    add_outline=False,\n    frameon=False,\n    spot_size=.8,\n    library_id='CytAssist_FFPE_Human_Breast_Cancer',\n    color_map=\"mako_r\"\n)\n</code></pre>"},{"location":"tutorials/mapping_sc_st/#integration-with-single-cell-spatial-and-in-situ-analysis","title":"Integration with single cell, spatial and in situ analysis","text":""},{"location":"tutorials/mapping_sc_st/#import-the-packages","title":"import the packages","text":""},{"location":"tutorials/mapping_sc_st/#load-st-and-sc-rna-seq-data","title":"Load ST and sc-RNA seq data","text":""},{"location":"tutorials/mapping_sc_st/#deconvolute-st-data-with-sc-rna-seq-as-the-reference","title":"Deconvolute ST data with sc-RNA seq as the reference.","text":""},{"location":"tutorials/mapping_sc_st/#mapping-scrna-seq-to-st-data","title":"Mapping scRNA-seq to ST data","text":""},{"location":"tutorials/mapping_sc_st/#read-the-cell-count-data-for-each-spotoptional","title":"Read the cell count data for each spot(optional).","text":""},{"location":"tutorials/mapping_sc_st/#mapping","title":"Mapping","text":""}]}